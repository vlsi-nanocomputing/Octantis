// Standard C++ Include Files
#include <cmath>
#include <fstream>
#include <iostream>
#include <system_error>

// Debug
#include <stdexcept>

// LLVM include files
#include "PrintVhdlFile.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/FileSystem.h"

using namespace octantis;
using namespace llvm;

/// It prints the .vhd file
void PrintVhdlFile::print() {

  // declaration of the output .vhd file
  std::string outFileName = "ComponentName.vhd";

  // error handling section
  std::error_code ErrorInfo;

  outFile =
      new raw_fd_ostream(outFileName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
  if (ErrorInfo) {
    errs() << "Error opening file: " << outFileName << "\n";
    llvm_unreachable("Error in PrintVhdlFile: unable to create the .vhd file.");
  }

  // first part of the .vhd file
  *outFile << "--#-----------------------------------------------#\n"
           << "--# .vhd file generated by Octantis tool #\n"
           << "--#-----------------------------------------------#\n\n\n";

  // Printing the content of the different sections: Libraries, Entity and Architecture parts
  printLib();
  printEntity();
  printArchitecture();

  // Closing the file
  (*outFile).close();

  errs() << "Octantis: end .vhd file generation process!\n\n";
}

/// This function prints the imported libraries declaration part
void PrintVhdlFile::printLib() {
  *outFile << "-- Imported libraries section\n"
           << "library ieee;\n"
           << "use ieee.std_logic_1164.all;\n\n\n";
}

/// It is the function devoted to the printing of the ENTITY declaration part
/// inside the .vhd file
void PrintVhdlFile::printEntity() {
  // CLK and RST are fixed, while other inputs have to be detected
  *outFile
      << "entity EntityName is\n"
      << "\tport(\n";

  // Cycling over the LiMArray coonsidering each LiMRow
  for (limArrayIT = ((*compArray).limArray).begin();
       limArrayIT != ((*compArray).limArray).end(); ++limArrayIT) {

    // Check if there are input operands
    if (((limArrayIT->second).inputConnections).front() == (int *)0xdef) {
      // Input operand detected and added to the list of inputs in the entity section
      *outFile << "\t\t"
               << "ROW_" << limArrayIT->first << "_input"
               << " : in std_logic_vector(" << par << " - 1 downto 0);\n";
    }
  }

  *outFile  << "\t\tRST : in std_logic;\n"
      << "\t\tCLK : in std_logic);\n";

  // Check for output pins presence

  // ending the entity section;
  *outFile << "end EntityName;\n\n";
}

/// It is the function devoted to the printing of the ARCHITECTURE part
/// inside the .vhd file
void PrintVhdlFile::printArchitecture() {

  // Components declaration support file
  std::string compDecName = ".compDec.vhd";
  std::error_code ErrorInfoCompDec;
  compDec = new raw_fd_ostream(compDecName.c_str(), ErrorInfoCompDec,
                               llvm::sys::fs::F_None);
  if (ErrorInfoCompDec) {
    errs() << "Error opening file: " << compDecName << "\n";
    llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
  }

  // Signals declaration support file
  std::string sigDecName = ".sigDec.vhd";
  std::error_code ErrorInfoSigDec;
  sigDec = new raw_fd_ostream(sigDecName.c_str(), ErrorInfoSigDec,
                              llvm::sys::fs::F_None);
  if (ErrorInfoSigDec) {
    errs() << "Error opening file: " << sigDecName << "\n";
    llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
  }

  // Components instantiation support file
  std::string compInstName = ".compInst.vhd";
  std::error_code ErrorInfoCompInst;
  compInst = new raw_fd_ostream(compInstName.c_str(), ErrorInfoCompInst,
                                llvm::sys::fs::F_None);
  if (ErrorInfoCompInst) {
    errs() << "Error opening file: " << compInstName << "\n";
    llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
  }

  // Memory Cell component declaration
  *compDec << "architecture struct of EntityName is\n"
           << "\tcomponent MemCell\n"
           << "\t\tport(\n"
           << "\t\tRST: in std_logic;\n"
           << "\t\tCLK: in std_logic;\n"
           << "\t\tEN: in std_logic;\n"
           << "\t\tRD: out std_logic;\n"
           << "\t\tWR: in std_logic);\n"
           << "\tend component;\n\n";

  // operand type defined in LimOperations of OperationsImplemented (value field)
  std::string opType;
  // operator defined in LimOperations of OperationsImplemented (key field)
  std::string op;
  // source Row whose output is connected to the Memory Cells of the currentRow
  int *srcRow1;
  // source Row whose output is connected to the internal logic (bitwise_operator/FA/HA/MUX21) of the currentRow
  int *srcRow2;
  // source Row whose output is connected to the internal logic (bitwise_operator/FA/HA/MUX21) of the currentRow
  int *srcRow3;
  // true if a MUX21 is needed
  bool isMux;
  // true if a MUX21 is needed, but this variable will be used in order to insert its declaration
  // in the component declaration part
  bool isMux21Present;
  // true if an addition is present, used in order to declare HA and FA in the component declaration section
  bool isAddPresent;
  // list containing all the sizes of the other muxes needed (switch case)
  std::list<int> otherMuxesWidth;
  // useful in order to know if an equal mux size has already been found
  bool elFound = false;

  // Cycling over the limArray which is a map whose mapped value field is a
  // LiMRow
  for (limArrayIT = ((*compArray).limArray).begin();
       limArrayIT != ((*compArray).limArray).end(); ++limArrayIT) {

    // If the number of input connection to the row is greater than 1,
    // a mux has to be inserted inside the array
    isMux = (((limArrayIT->second).inputConnections).size() > 2) ? true : false;

    // retrieving the name of the current row from the key field of the limArray map
    int *const rowName = (limArrayIT->first);

    // string that completes the string reffering to the signal given in input
    // to a limCell it will be "_OUT" when the srcRow1 is another limRow,
    // "_input" if the signal is an input one
    std::string limRowInputcomp;

    // checking if the operation relative to the LiMRow is present in the set of
    // possible operations
    std::map<std::string, std::string>::const_iterator OpImplIT =
        LimOperations.find((limArrayIT->second).rowType);

    // Check if it is a recognized operation
    if (OpImplIT != LimOperations.end()) {

      // opType refers to the operation type defined in OperationsImplemented.h,
      // that is to say null, bitwise, arith, while op refers to the instruction
      // itself, such as load, xor, etc...
      opType = OpImplIT->second;
      op = OpImplIT->first;

      if (opType == "null") {
        
        // Check if there are input operands
        if (((limArrayIT->second).inputConnections).front() != (int *)0xdef) {
          // Result memory row
          srcRow1 = (((limArrayIT->second).inputConnections).front());

          // signal representing the data read from the current row memory cells and given
          // in input to the current row logic
          *sigDec << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
                  << "- 1 downto 0);\n";

          // signal representing the data in output from the current LiMRow
          *sigDec << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector("
                  << par << "- 1 downto 0);\n";

          // inserting a memory result row in the component instantiation section
          *compInst
              << "\t-- Memory result row\n"
              << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
              << " - 1 generate\n"
              << "\t\tMEM" << rowName
              << "PM : MemCell port map(RST => RST, CLK => CLK, RD => ROW_"
              << rowName << "_MEM_RD(i), WR => ROW_" << srcRow1 << "_OUT(i));\n"              
              << "\t\tROW_" << rowName <<"_OUT(i) <= ROW_" << rowName << "_MEM_RD(i);\n"
              << "\tend generate;\n\n";
        } else {
          // Source memory Row

          // inserting a memory source row in the component instantiation section
          *compInst
              << "\t-- Memory source row\n"
              << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
              << " - 1 generate\n"
              << "\t\tMEM" << rowName
              << "PM : MemCell port map(RST => RST, CLK => CLK,";

          if(isInputToMux(rowName)){
            // signal representing the data read from the current row memory cells and given
            // in input to the current row logic
            *sigDec << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
                  << "- 1 downto 0);\n";

            *compInst << " RD => ROW_" << rowName << "_MEM_RD(i), ";
          }

          if(isInputToAnotherLimCell(rowName)){
            // signal representing the data in output from the current LiMRow
            *sigDec << "\tsignal ROW_" << rowName << "_OUT std_logic_vector("
                    << par << "- 1 downto 0);\n";

            *compInst << " RD => ROW_" << rowName << "_OUT(i), ";
          }
          
            *compInst << " WR => ROW_" << rowName << "_input(i))\n"
                      << "\tend generate;\n\n";
        }

      } else if (opType == "bitwise") {

        if (isMux) {
          // it will be needed to add the MUX21 declaration
          isMux21Present = true;
          // source row 1
          srcRow1 =
              isInputRow((((limArrayIT->second).inputConnections).front()))
                  ? rowName
                  : (((limArrayIT->second).inputConnections).front());
          // source row 2
          srcRow2 =
              *(std::next(((limArrayIT->second).inputConnections).begin(), 1));
          // source row 3
          srcRow3 = (((limArrayIT->second).inputConnections).back());

          // completing the string for the source signal for the limCell
          limRowInputcomp = (srcRow1 == rowName) ? "_input" : "_OUT";

          printBitwiseMux2to1(op, rowName, srcRow1, limRowInputcomp, srcRow2,
                              srcRow3, sigDec, compDec);

        } else if ((limArrayIT->second).rowType == "switch") {
          // source row 1
          srcRow1 =
              isInputRow((((limArrayIT->second).inputConnections).front()))
                  ? rowName
                  : (((limArrayIT->second).inputConnections).front());
          // source row 2
          srcRow2 =
              *(std::next(((limArrayIT->second).inputConnections).begin(), 1));

          // completing the string for the source signal for the limCell
          limRowInputcomp = (srcRow1 == rowName) ? "_input" : "_OUT";

          // cycling over the muxes size list in order to check if the current one has already been found
          for(std::list<int>::iterator listIT = otherMuxesWidth.begin(); listIT != otherMuxesWidth.end(); ++listIT){
            if(*listIT == (int)(((limArrayIT->second).additionalLogic).size())){
              elFound = true;
            }
          }

          // if the same mux size has already been found, the current one must not be pushed in the list
          if(!elFound){
            otherMuxesWidth.push_back(((limArrayIT->second).additionalLogic).size());
          }
          elFound = false;          

          printMixed(op, rowName, srcRow1, srcRow2, limRowInputcomp,
                     (limArrayIT->second).additionalLogic, sigDec, compInst);

        } else {

          // printBITWISE
          srcRow1 =
              isInputRow((((limArrayIT->second).inputConnections).front()))
                  ? rowName
                  : (((limArrayIT->second).inputConnections).front());
          srcRow2 =
              *(std::next(((limArrayIT->second).inputConnections).begin(), 1));

          // completing the string for the source signal for the limCell
          limRowInputcomp = (srcRow1 == rowName) ? "_input" : "_OUT";

          printBitwise(rowName, srcRow1, srcRow2, limRowInputcomp, op, sigDec,
                       compInst);
        }

      } else if (opType == "arith") {
        // it will be needed to add the FA/HA declaration
        isAddPresent = true;

        if (isMux) {
          // it will be needed to add the MUX21 declaration
          isMux21Present = true;

          // source row 1
          srcRow1 =
              isInputRow((((limArrayIT->second).inputConnections).front()))
                  ? rowName
                  : (((limArrayIT->second).inputConnections).front());
          // source row 2
          srcRow2 =
              *(std::next(((limArrayIT->second).inputConnections).begin(), 1));
          // source row 3
          srcRow3 = (((limArrayIT->second).inputConnections).back());

          // completing the string for the source signal for the limCell
          limRowInputcomp = (srcRow1 == rowName) ? "_input" : "_OUT";

          printAddMux2to1(rowName, srcRow1, limRowInputcomp, srcRow2, srcRow3,
                          sigDec, compInst);

        } else {

          // source row 1
          srcRow1 =
              isInputRow((((limArrayIT->second).inputConnections).front()))
                  ? rowName
                  : (((limArrayIT->second).inputConnections).front());
          // source row 2
          srcRow2 =
              *(std::next(((limArrayIT->second).inputConnections).begin(), 1));

          // completing the string for the source signal for the limCell
          limRowInputcomp = (srcRow1 == rowName) ? "_input" : "_OUT";

          printAdd(rowName, srcRow1, srcRow2, limRowInputcomp, sigDec,
                   compInst);
        }

      } else {
        llvm_unreachable(
            "Error in PrintVhdlFile: unknow operation returned from "
            "LimOperations.");
      }

    } else {
      llvm_unreachable("Error in PrintVhdlFile: unknown compiled operation. "
                       "The name is not present inside LimOperations map.");
    }
  }

  // if a MUX21 is needed, it must be declared
  if(isMux21Present){
    *compDec << "\tcomponent MUX21 is\n"
           << "\t\tport(\n"
           << "\t\tA: in std_logic;\n"
           << "\t\tB: in std_logic;\n"
           << "\t\tSEL: in std_logic;\n"
           << "\t\tY: out std_logic);\n"
           << "\t end component;\n\n";
  }

  // if an ADD is needed, FA/HA must be declared
  if(isAddPresent){
    *compDec << "\tcomponent FA is\n"
            << "\t\tport(\n"
            << "\t\tA: in std_logic;\n"
            << "\t\tB: in std_logic;\n"
            << "\t\tCin: in std_logic;\n"
            << "\t\tS: out std_logic;\n"
            << "\t\tCout: out std_logic);\n"
            << "\t end component;\n\n";

    *compDec << "\tcomponent HA is\n"
            << "\t\tport(\n"
            << "\t\tA: in std_logic;\n"
            << "\t\tB: in std_logic;\n"
            << "\t\tS: out std_logic;\n"
            << "\t\tCout: out std_logic);\n"
            << "\t end component;\n\n";
  }

  // cycling over the list of mux sizes
  for(std::list<int>::iterator listIT = otherMuxesWidth.begin(); listIT != otherMuxesWidth.end(); ++listIT){
    // foreach size a mux must be declared inside the component declaration section
    *compDec << "\tcomponent MUX" << *listIT << "1 is\n"
               << "\t\tport(\n"; 

    // inserting new pins
    for (int i = 0; i < *listIT; i++)
    {
      *compDec << "\t\tIN_" << i << ": in std_logic;\n";
    }    

    // declaring the selection signal with a parallelism which is log2 od the mux dimension
    *compDec << "\t\tSEL: in std_logic_vector(" << (int)(log2(*listIT)) << " - 1 downto 0);\n" 
            << "\t\tY: out std_logic);\n" << "\t end component;\n\n"; 
  }

  *sigDec << "\nbegin\n\n";
  *compInst << "\nend struct;\n";
  // The content of compDec will be copied into outFile and will be closed
  mergeToOutFile(outFile, compDec, compDecName, true);
  // The content of sigDec will be copied into outFile and will be closed
  mergeToOutFile(outFile, sigDec, sigDecName, true);
  // The content of compInst will be copied into outFile and will be closed
  mergeToOutFile(outFile, compInst, compInstName, true);
}

/// It returns true if the input LiMRow is has an input which is not the output of another LiMRow
bool PrintVhdlFile::isInputRow(int *const &rowName) {
  return (rowName == (int *)0xdef) ? true : false;
}

/// It merges the source file into the destination file
/// The source file is closed if closeSource is true
void PrintVhdlFile::mergeToOutFile(raw_fd_ostream *destFD,
                                   raw_fd_ostream *sourceFD,
                                   std::string &sourceName,
                                   bool closeSourceFD) {

  char ch;

  // Declaration of tmp file in order to implement the merge operation
  std::fstream sourceFile;

  // Closing the file descriptor in order to be reopened in std C++
  (*sourceFD).close();

  sourceFile.open(sourceName, std::fstream::in);
  if (!sourceFile.is_open()) {
    errs() << "Error opening file: " << sourceName << "\n";
    llvm_unreachable(
        "Error in PrintDexFile::mergeToOutFile: unable to open a file.");
  }

  // Copy content from sourceFile to outFile
  while (!sourceFile.eof()) {
    sourceFile >> std::noskipws >> ch;
    *destFD << ch;
  }

  sourceFile.close();
}

/// It prints the correct code for any BITWISE lim cell
void PrintVhdlFile::printBitwise(int *const &rowName, int *const &srcRow1,
                                 int *const &srcRow2, std::string &limRowComp,
                                 std::string &bitwiseOp,
                                 raw_fd_ostream *const &sigFd,
                                 raw_fd_ostream *const &compFd) {
  // declaration of the intermediate signals:
  // signal representing the
  // data read from the current row memory cells and given
  // in input to the current row logic
  *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the data in output from the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  *compFd << "\t-- Bitwise\n"
          << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
          << " - 1 generate\n"

          << "\t\tMEM_" << rowName
          << "_PM: MemCell port map(RST => RST, CLK => CLK, RD => ROW_"
          << rowName << "_MEM_RD(i), WR => ROW_" << srcRow1 << limRowComp
          << "(i));\n"

          << "\t\tROW_" << rowName << "_OUT(i) <= "
          << "ROW_" << rowName << "_MEM_RD(i) " << bitwiseOp << " ROW_"
          << srcRow2 << "_MEM_RD(i);\n"
          << "\tend generate;\n\n";
}

/// It prints the correct code for any MIXED lim cell
void PrintVhdlFile::printMixed(std::string &bitwiseOp, int *const &rowName,
                               int *const &srcRow1, int *const &srcRow2,
                               std::string &limRowComp,
                               std::list<std::string> &operators,
                               raw_fd_ostream *const &sigFd,
                               raw_fd_ostream *const &compFd) {

  // Out mux dimension
  int muxDimension = operators.size();

  // Counter for mux inputs
  int muxCount = 0;

  if ((muxDimension & (muxDimension - 1)) != 0) {
    // Error in the definition of the input mux: not a power of two!
    llvm_unreachable("Error in PrintDexFile: the mux of the LiM row is not "
                     "properly defined!");
  }

  // declaration of the intermediate signals:
  // signal representing the data read from the current row memory cells
  // and given in input to the current row logic
  *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
         << " - 1 downto 0);\n";

  // signal representing the data in output from the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
         << " - 1 downto 0);\n";

  // signal representing the selection signal of the inner mux
  *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic_vector("
         << (int)(log2(muxDimension)) << " - 1 downto 0);\n";

  // check if operand is from source row
  *compFd << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
          << " - 1 generate\n"

          << "\t\tMEM_" << rowName
          << "_PM: MemCell port map(RST = > RST, CLK = > CLK, RD = > ROW_"
          << rowName << "_MEM_RD(i), WR = > ROW_" << srcRow1 << limRowComp
          << "(i));\n"

          << "\t\t MUX_" << rowName << "_PM: MUX21 port map(";

  // assigning signals to the various pins of the mux
  for (auto listIT = operators.begin(); listIT != operators.end(); listIT++) {
    *compFd << "IN_" << muxCount << " => "
            << "ROW_" << rowName << "_OP" << muxCount << "_OUT(i), ";
    ++muxCount;
  }

  // assigning the selection signal
  *compFd << "SEL"
          << " => "
          << "ROW_" << rowName << "_SEL, "
          << "Y => ROW_" << rowName << "_OUT(i));\n";

  muxCount = 0;

  // assigning the various output signals of the operators
  for (auto listIT = operators.begin(); listIT != operators.end(); listIT++) {

    *compFd << "\t\tROW_" << rowName << "_OP" << muxCount << "_OUT(i) <= "
            << "ROW_" << rowName << "_MEM_RD(i) " << *listIT << " ROW_" << srcRow2
            << "_MEM_RD(i);\n";    

    // signal representing the output data of the internal operator and must be added to the declaration section
    *sigFd << "\tsignal ROW_" << rowName << "_OP" << muxCount
           << "_OUT: std_logic_vector(" << par << "- 1 downto 0);\n";

    ++muxCount;
  }

  *compFd << "\tend generate;\n\n";
}

/// It prints the correct code for any BITWISE lim cell with a 2to1 mux in
/// input
/// so that 2 input bits for the logic are available.
void PrintVhdlFile::printBitwiseMux2to1(
    std::string &bitwiseOp, int *const &rowName, int *const &srcRow1,
    std::string &limRowComp, int *const &srcRow2, int *const &srcRow3,
    raw_fd_ostream *const &sigFd, raw_fd_ostream *const &compFd) {
  // declaration of the intermediate signals:
  // signal representing the data read from the current row memory cells
  // and given in input to the current row logic
  *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the data in output from the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the selection signal of the mux of the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic;\n";

  // signal representing the output data of the internal 2-to-1 mux of
  // the LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_MUX_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  
  *compFd << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
          << " - 1 generate\n"

          << "\t\tMEM_" << rowName
          << "_PM: MemCell port map(RST = > RST, CLK = > CLK, RD = > ROW_"
          << rowName << "_MEM_RD(i), WR = > ROW_" << srcRow1 << limRowComp
          << "(i));\n"

          << "\t\t MUX_" << rowName << "_PM: MUX21 port map(A => ROW_"
          << srcRow2 << "_MEM_RD(i), B => ROW_" << srcRow3
          << "_MEM_RD(i), SEL => "
          << "ROW_" << rowName << "_SEL,"
          << "Y => ROW_" << rowName << "_MUX_OUT(i));\n"

          << "\t\tROW_" << rowName << "(i) <= "
          << "ROW_" << rowName << "_MEM_RD(i)" << bitwiseOp << "ROW_" << rowName
          << "_MUX_OUT(i);\n"
          << "\tend generate;\n\n";
}

/// It prints the correct code for an SUM lim cell with a 2to1 mux in input
/// so that 2 input bits for the logic are available.
void PrintVhdlFile::printAddMux2to1(int *const &rowName, int *const &srcRow1,
                                    std::string &limRowComp,
                                    int *const &srcRow2, int *const &srcRow3,
                                    raw_fd_ostream *const &sigFd,
                                    raw_fd_ostream *const &compFd) {
  // declaration of the intermediate signals:
  // signal representing the data read from the current row memory cells
  // and given in input to the current row logic
  *sigFd << "s\tignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the selection signal of the mux of the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic;\n";

  // signal representing the data in output from the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the carry out chain
  *sigFd << "\tsignal ROW_" << rowName << "_COUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the output data of the internal 2-to-1 mux of
  // the LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_MUX_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  
  *compFd << "\t-- Add mixed\n"
          << "\tROW_" << rowName << "_GEN: for i in 0 to" << par
          << " - 1 generate\n"
          << "\t\tMEM_" << rowName
          << "_PM : MemCell port map(RST => RST, CLK => CLK, RD => ROW_"
          << rowName << "_MEM_RD(i), WR => ROW_" << srcRow1 << limRowComp
          << "(i));\n"
          << "\t\tMUX" << rowName << "i_PM: MUX21 port map(A => ROW_" << srcRow2
          << "_MEM_RD(i), B => ROW_" << srcRow3 << "_MEM_RD(i), SEL => "
          << "ROW_" << rowName << "_SEL,"
          << " Y = > ROW_" << rowName << "_MUX_OUT(i));\n "
          << "\t\tROW_" << rowName << "_IF: if i = 0 generate\n"
          << "\t\t\tHA_" << rowName << "_PM: HA port map(A => ROW_" << rowName
          << "_MEM_RD(i), B => ROW_" << rowName
          << "_MUX_OUT(i), Cout => ROW_" << rowName
          << "_COUT(i), S => ROW_" << rowName << "_OUT(i));\n"
          << "\t\tend generate;\n"
          << "\t\tFA_i_PM: FA port map(A => ROW_" << rowName
          << "_MEM_RD(i), B => ROW_" << rowName << "_MUX__OUT(i), Cin => ROW_"
          << rowName << "_COUT(i - 1), Cout => ROW_" << rowName
          << "_COUT(i), S => ROW_" << rowName << "_OUT(i));\n"
          << "\tend generate;\n";
}

/// It prints the correct code for an SUM lim cell
void PrintVhdlFile::printAdd(int *const &rowName, int *const &srcRow1,
                             int *const &srcRow2, std::string &limRowComp,
                             raw_fd_ostream *const &sigFd,
                             raw_fd_ostream *const &compFd) {
  // declaration of the intermediate signals:
  // signal representing the data read from the current row memory cells
  // and given in input to the current row logic
  *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the data in output from the current LiMRow
  *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  // signal representing the carry out chain
  *sigFd << "\tsignal ROW_" << rowName << "_COUT: std_logic_vector(" << par
         << "- 1 downto 0);\n";

  
  *compFd << "\t-- Add\n"
          << "\tROW_" << rowName << "_GEN: for i in 0 to " << par
          << " - 1 generate\n"

          << "\t\tMEM_" << rowName
          << "_PM: MemCell port map(RST => RST, CLK => CLK, RD => ROW_"
          << rowName << "_MEM_RD(i), WR => ROW_" << srcRow1 << limRowComp
          << "(i));\n"

          << "\t\tROW_" << rowName << "_IF: if i = 0 generate\n"
          << "\t\t\tHA_" << rowName << "_PM : HA port map(A => ROW_" << rowName
          << "_MEM_RD(i), B => ROW_" << srcRow2
          << "_MEM_RD(i), Cout => ROW_" << rowName
          << "_COUT(i), S => ROW_" << rowName << "_OUT(i));\n"
          << "\t\tend generate;\n"
          << "\t\tFA_" << rowName << "_PM: FA port map(A => ROW_" << rowName
          << "_MEM_RD(i), B => ROW_" << srcRow2 << "_MEM_RD(i), Cin => ROW_"
          << rowName << "_COUT(i - 1), Cout => ROW_" << rowName
          << "_COUT(i), S = > ROW_" << rowName << "_OUT(i));\n"
          << "\tend generate;\n\n";
}

/// returns true if the output of the input LiMRow is given in input to another row limcell
bool PrintVhdlFile::isInputToAnotherLimCell(int * const &rowName){
  for(auto mapIT=((*compArray).limArray).begin(); mapIT != ((*compArray).limArray).end(); ++mapIT){
    if(((mapIT->second).inputConnections).front() == rowName){
      return true;
    }
  }
  return false;
}

/// returns true if the output of the input LiMRow is given in input to another row mux
bool PrintVhdlFile::isInputToMux(int * const &rowName){
  for(auto mapIT=((*compArray).limArray).begin(); mapIT != ((*compArray).limArray).end(); ++mapIT){
    if(((mapIT->second).inputConnections).back() == rowName ||
        *(std::next(((limArrayIT->second).inputConnections).begin(), 1)) == rowName){
      return true;
    }
  }
  return false;
}