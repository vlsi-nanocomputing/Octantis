/*-------------------------------------- The Octantis Project --------------------------------------*/
//
// PrintDexFile Class: class useful for the definition of Dexima's configuration file (.dex).
//      *Note: For the syntax description, refer to Dexima's documentation.
//
/*-------------------------------------------- Licence ---------------------------------------------*/
//
// Â© Alessio Nicola 2021 (alessio.nicola@studenti.polito.it) for Politecnico di Torino
//
/*--------------------------------------------------------------------------------------------------*/

#include "PrintDexFile.h"

// Standars C++ Include Files
#include <cmath>
#include <fstream>
#include <iostream>

// LLVM include files
#include "llvm/Support/FileSystem.h"

using namespace octantis;
using namespace llvm;

/// It prints the .dex file
void PrintDexFile::print(){
    
    // Definition of the Output file
    std::string outFileName = "config.dex";
    std::error_code ErrorInfo; 
//    raw_fd_ostream outFile(outFileName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
    outFile = new raw_fd_ostream(outFileName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
    if (ErrorInfo){
        errs() << "Error opening file: " << outFileName << "\n";
        llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
    }

    
    // Code section support file
    std::string outCodeName = ".code.dex";
    outCode = new raw_fd_ostream(outCodeName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
    if (ErrorInfo){
        errs() << "Error opening file: " << outCodeName << "\n";
        llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
    }


    //eventualmente inserire versione di octantis e data di generazione...
    *outFile    << "#-----------------------------------------------#\n"
                << "# Configuration file generated by Octantis tool #\n"
                << "#-----------------------------------------------#\n";

    // Printing the content of the different sections:
    printConstants();
    printInit();
    printLiM();
    printMap();
    printInstructions();
    printCode(outCodeName);
    
    (*outFile).close();

    errs() << "Octantis finished the synthesis process. Goodbye!\n\n";

}


/// It prints the Constants section
void PrintDexFile::printConstants(){
    //valutare se inserire una struttura dati per le builtin
    //in modo da renderlo modulare per future implementazioni
    //di file di configurazione octantis e/o interfaccia grafica

    *outFile << "begin constants\n\n";
    // Printing the CONSTANTS section of Dexima's conf.file

    *outFile << "\t#Decomment and modify the desired constants\n\n";

    *outFile << "\t#Supply voltage [V] - Default TechFile\n";
    *outFile << "\t#N.B. Modifying Vdd can cause unexpectd or wrong values of performance\n";
    *outFile << "\t#BUILT_IN VDD 0.9\n\n";

    *outFile << "\t#Clock period [ns] - Default Critical Path\n";
    *outFile << "\t#BUILT_IN CLOCK 2\n\n";

    *outFile << "\t#Aspect Ratio of unitary N-mos - Default TechFile\n";
    *outFile << "\t#BUILT_IN AR 4\n\n";

    *outFile << "\t#Stack factor - Default 2\n";
    *outFile << "\t#BUILT_IN SF 1\n\n";

    *outFile << "\t#Tecnology node - Default 45\n";
    *outFile << "\t#BUILT_IN NODE 32\n\n";

    *outFile << "\t#Technology type - Default LOP\n";
    *outFile << "\t#BUILT_IN TECH HP\n\n";

    *outFile << "\t#Switching computation - Default OFF\n";
    *outFile << "\t#BUILT_IN SWITCHING ON\n\n";

    *outFile << "\t#Input probability - Default 0.5\n";
    *outFile << "\t#BUILT_IN PROB 0.6\n\n";

    *outFile << "end constants\n\n";

}

/// It prints the Init section
void PrintDexFile::printInit(){
    
    *outFile << "begin init\n\n";
    // Printing the INIT section of Dexima's configuration file

    *outFile << "\tCK_DRIVER ClockDriver(4)\n\n";

    // Also here the parallelism of the memory has to be defined
    // into a configuration file.
    *outFile << "\tLIM LiM(" << (int)ceil(log2((*compArray).getDimensions()))
            << ", " << par << ")\n";

    *outFile << "\nend init\n\n";

}

/// It prints the Lim section
void PrintDexFile::printLiM(){
    
    // LiM Map section support file
    std::string outLiMMapName =".outLiMMap.dex";
    std::error_code ErrorInfo; 
    outLiMMap = new raw_fd_ostream(outLiMMapName.c_str(), ErrorInfo, sys::fs::F_None);
    if (ErrorInfo){
        errs() << "Error opening file: " << outLiMMapName << "\n";
        llvm_unreachable("Error in PrintDexFile: unable to create a tmp LiMMap file.");
    }

    // Variable to know the current row analyzed
    int currentRow=0;
    
    *outFile << "begin LiM\n\n";
    // Printing the LIM section of Dexima's conf.file

    // MEMDEF REGION - Definition of LiM parallelism //////////////////////////
    *outFile << "\tbegin memdef\n\n";
    
    *outFile << "\t\tROWS " << (int)pow(2,(int)ceil(log2((*compArray).getDimensions())))<<"\n";
    *outFile << "\t\tCOLUMNS " << par << "\n";
    *outFile << "\t\tTYPE FLIPFLOP\n\n";

    *outFile << "\tend memdef\n\n";

    // LOGIC REGION - Logic outside the memory cells //////////////////////////
    *outFile << "\tbegin logic\n\n";
    
    //The section should be implemented as a future works:
    //this section is useful to describe intra row-column logic.
    
    *outFile << "\tend logic\n\n";

    // CELL REGION - Logic inside the memory cells ////////////////////////////
    *outFile << "\tbegin cells\n\n";

    // Read the LiM Array and print the associated code
    for(limArrayIT=((*compArray).limArray).begin();
        limArrayIT!=((*compArray).limArray).end(); ++limArrayIT){
        
        errs() << "\nLimArray cycle\n";
        identifyLIMRowAndPrint(currentRow, &limArrayIT);
        ++currentRow;
    }

    *outFile << "\n\tend cells\n\n";

    // MAP REGION - LiM Map ///////////////////////////////////////////////////
    *outFile << "\tbegin map\n\n";

    // The content of outLiMMap will be copied into outFile and will be closed
    mergeToOutFile(outFile, outLiMMap, outLiMMapName, true);

    *outFile << "\tend map\n\n";
    
    *outFile << "end LiM\n\n";

}

/// It prints the Map section
void PrintDexFile::printMap(){
    
    *outFile << "begin map\n\n";
    
    *outFile << "\tClockDriver.OUT -> LiM.CK\n\n";

    // This code section will be updated when the outside logic
    // will be included into the design.

    *outFile << "end map\n\n";

}

/// It prints the Instructions section
void PrintDexFile::printInstructions(){

    // Helps to recognize the first element of FSMIT
    int i=0;
    
    // String where to compose the instruction name that will be printed
    std::string instrName;

    // Instructions section support file
    std::string outInstrName = ".outInstr.dex";
    std::error_code ErrorInfo;
    outInstr = new raw_fd_ostream(outInstrName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
    if (ErrorInfo){
        errs() << "Error opening file: " << outInstrName << "\n";
        llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
    }

    // Instructions power section support file
    std::string outInstrPowerName = ".outInstrPower.dex";
    // Instructions path section support file
    std::string outInstrPathName = ".outInstrPath.dex";


    *outFile << "begin instructions\n\n";

    // Specification of the active blocks during the execution of a
    // declared instruction (printed in the same order):
    for (FSMIT=((*compFSM).FSM).begin(); FSMIT!=((*compFSM).FSM).end(); ++FSMIT) {
        
        ///////////////////////////////////////////////////////////////////////////////////////////////
        //Risolvere problema nella funzione merge in modo che lasci il file aperto
        //per togliere queste righe...
        outInstrPower = new raw_fd_ostream(outInstrPowerName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
        if (ErrorInfo){
            errs() << "Error opening file: " << outInstrPowerName << "\n";
            llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
        }

        outInstrPath = new raw_fd_ostream(outInstrPathName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
        if (ErrorInfo){
            errs() << "Error opening file: " << outInstrPathName << "\n";
            llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////

        instrName="";
        i=0;

        //Declaration of the active cells, iteration over the operation list
        for (FSM_ListIT=(FSMIT->second).begin(); FSM_ListIT!=(FSMIT->second).end();
            ++FSM_ListIT) {
            
            // Recovery information about the cell used by FSM
            limArrayIT=((*compArray).limArray).find(*FSM_ListIT);

            if (i!=0){
                instrName+="_";
            }
            
            instrName+=(limArrayIT->second).rowType+std::to_string(FSMIT->first);

            i++;

        }

        // Implement both power and path section
        powerPathSection();


        // The first instruction is not considered because they are all load
        // (by definition of LLVM), and it could be useful only to include in
        // DExIMA analysis the memory interface
        if (FSMIT->first != 0) { // Must be removed to use the memory interface

            // Could be useful for future implementation when it is necessary
            // to use the memory interface
            //if (FSMIT->first==0) {
            //    *outFile << "\tINSTRUCTION " << instrName << "\n";
            //    ...
            //} else {
            *outFile << "\tLIM_INSTRUCTION LiM " << instrName << "\n";
            //    ...
            //}
            
            *outInstr << "\n\tbegin " << instrName << "\n\n";
            *outInstr << "\t\tPIPELINE 0\n";
            
            // Power section
            *outInstr << "\n\t\tbegin power\n\n";
            mergeToOutFile(outInstr, outInstrPower, outInstrPowerName, true);
            *outInstr << "\t\tend power\n";

            // Path section
            *outInstr << "\n\t\tbegin path[0]\n\n";
            mergeToOutFile(outInstr, outInstrPath, outInstrPathName, true);
            *outInstr << "\t\tend path[0]\n";
            
            *outInstr << "\n\tend " << instrName << "\n";

            // Code section
            *outCode << "\n\t " << instrName << " 1\n";

        }
        
    }

    (*outInstrPower).close();
    (*outInstrPath).close();

    mergeToOutFile(outFile, outInstr, outInstrName, true);

    *outFile << "end instructions\n\n";

}

/// It prints the Code section
void PrintDexFile::printCode(std::string &outCodeName){

    *outFile << "begin code\n";
    
    mergeToOutFile(outFile, outCode, outCodeName, true);

    *outFile << "end code";

}

/// It identifies the kind of LiM row
void PrintDexFile::identifyLIMRowAndPrint(int &currentRow,
    std::map<int * const, LiMArray::LiMRow>::iterator * mapIT){
    
    // If the number of input connection to the row is greater than 1, 
    // a mux has to be inserted inside the array
    bool isMux = ((((*mapIT)->second).inputConnections).size()>2) ? true : false;

    std::string opType;

    int * const rowName=((*mapIT)->first);

    std::map<std::string, std::string>::const_iterator
        OpImplIT=LimOperations.find(((*mapIT)->second).rowType);

    errs()<< "The data from the Map is: " << ((*mapIT)->second).rowType <<"\n";

    // Check if it is a recognized operation
    if(OpImplIT!=LimOperations.end()){
        
        opType=OpImplIT->second;
        errs()<<"Operation type: "<<opType<<"\n";

        if(opType=="null"){
            errs() << "A load operation is considered!\n";

            // Check if there are input operands
            if((((*mapIT)->second).inputConnections).front() == (int*)0xdef){
                //Source memory row
                addDataRow(currentRow, rowName, nullptr);
            } else {
                //Result memory row
                addDataRow(currentRow, rowName, 
                    (((*mapIT)->second).inputConnections).front());
            }

        } else if(opType=="bitwise"){
            
            if(isMux) {
                printBITWISEMux2to1(((*mapIT)->second).rowType, currentRow, rowName,
                                    *(std::next((((*mapIT)->second).inputConnections).begin(), 1)),
                                    (((*mapIT)->second).inputConnections).back());

            } else if (((*mapIT)->second).rowType=="switch"){

                printMIXED(((*mapIT)->second).rowType, currentRow, rowName,
                            *(std::next((((*mapIT)->second).inputConnections).begin(),1)),
                            ((*mapIT)->second).additionalLogic);

            } else {

                printBITWISE(((*mapIT)->second).rowType, currentRow, rowName,
                            *(std::next((((*mapIT)->second).inputConnections).begin(),1)));

            }

        } else if(opType=="arith"){

            if(isMux) {
                printADDMux2to1(currentRow, rowName,
                                *(std::next((((*mapIT)->second).inputConnections).begin(),1)),
                                (((*mapIT)->second).inputConnections).back());

            } else {

                printADD(currentRow, rowName,
                        *(std::next((((*mapIT)->second).inputConnections).begin(),1)));
            }

        } else {
            llvm_unreachable("Error in PrintDexFile: unknow operation returned from LimOperations.");
        }

    } else {
       llvm_unreachable("Error in PrintDexFile: unknown compiled operation. "
        "The name is not present inside LimOperations map.");
    }

}

/// It is invoked when a normal memory row is declared: CHECK THE TYPE!
void PrintDexFile::addDataRow(int &currentRow, int* const &nameRow,
    int* const &nameSrc){

    // Name of the Output pin of the source row (if any)
    std::string outSrc;

    std::string sourceCells;
    int sourceCellsBaseIndex;

    // Update the NamesMap
    insertNamesMap(nameRow, "Memory", currentRow);

    if(nameSrc!=nullptr){
        // Result row
        getNameAndIndexOfSourceRow(nameSrc, sourceCells, sourceCellsBaseIndex);

        // Check if the source cells are FAs/HAs:
        getOutPinName(sourceCells, outSrc);
        errs()<<"SOURCE CELLS: "<<sourceCells<<"; baseIndex: "<<sourceCellsBaseIndex<<"\n";

        // Map Section
        *outLiMMap   << "\t\tfor i in range(0,1," << par-1 << "){ " << sourceCells
                    << "(" << sourceCellsBaseIndex << ",$i)." << outSrc
                    << " -> Memory(" << currentRow << ",$i).WR }\n";
    
    } else {
        // Source row
        // Nothing is done!
    }
}

/// It inserts a new element inside the namesMap
void PrintDexFile::insertNamesMap(int* const &rowName, std::string cellName,
    int &cellRow){
    
    errs() << "Data passed: " << rowName << ", cellName " <<cellRow << "\n";
    nameAndIndex structTmp={cellName, cellRow};
    namesMap.insert({rowName, structTmp});
}

/// It modifies the passed parameters (name and index) to return
/// the requested information
void PrintDexFile::getNameAndIndexOfSourceRow(int* const &sourceRow,
    std::string &sourceCellName, int &sourceCellRow){
    
    errs()<<"\nFinding: "<<sourceRow<<"\n";
    namesMapIT=namesMap.find(sourceRow);

    if(namesMapIT!=namesMap.end())
    {
        std::string sourceName=(namesMapIT->second).name;

        //Check if the source cell is MIXED Type
        auto position = sourceName.find("Mux");
        if(position != std::string::npos){

            sourceName = "Mux";
        }

        sourceCellName=sourceName;
        sourceCellRow=(namesMapIT->second).rowIndex;
    } else {
        llvm_unreachable("Error in PrintDexFile: Reference to namesMap NOT VALID.");
    }
}

/// It returns the correct out pin name of opSrc row:
/// it's useful for the identification of the output pin name
/// of the row in case of is an Arithmetic Operation.
void PrintDexFile::getOutPinName(std::string &opSrc, std::string &outPinName){

    std::string opSrcInt=opSrc;
    std::map<std::string, std::string>::const_iterator tmpIT;

    auto position = opSrc.find("Mux");
    if(position != std::string::npos)
    {
        opSrcInt = opSrc.substr(0,position);
    }

    //Impose Lower case conditon to implementedCell
    transform(opSrcInt.begin(), opSrcInt.end(), opSrcInt.begin(), ::tolower);

    tmpIT=LimOperations.find(opSrcInt);

    if(tmpIT!=LimOperations.end()&&((tmpIT->second)=="arith")){
        outPinName="S";
    } else {
        outPinName="OUT";
    }
}

/// It prints the correct code for any BITWISE lim cell with a 2to1 mux in input
/// so that 2 input bits for the logic are available.
///     (NOTE:Check the definition of the multiplexer!)
void PrintDexFile::printBITWISEMux2to1(std::string &bitwiseOp, int &currentRow,
    int* const &nameRow, int* const &nameSrc1, int* const &nameSrc2){

    // Support variable to store the Upper case string of bitwiseOp
    std::string implementedCell=bitwiseOp;

    //Name of the Output pin of the source rows
    std::string outSrc1;
    std::string outSrc2;

    std::string sourceCells1;
    int sourceCellsBaseIndex1;

    std::string sourceCells2;
    int sourceCellsBaseIndex2;

    getNameAndIndexOfSourceRow(nameSrc1, sourceCells1, sourceCellsBaseIndex1);
    getNameAndIndexOfSourceRow(nameSrc2, sourceCells2, sourceCellsBaseIndex2);

    //Check if the source cells are FAs/HAs:
    getOutPinName(sourceCells1, outSrc1);
    getOutPinName(sourceCells2, outSrc2);

    //Impose Upper case conditon to implementedCell
    transform(implementedCell.begin(), implementedCell.end(), implementedCell.begin(), ::toupper);

    //Also here the parallelism should refer to
    //a configuration file
    for(int i=0; i<32; ++i){

        //If the first MSB is considered
        if(i==0){
            insertNamesMap(nameRow, bitwiseOp+"Mux", currentRow);
        }

        //Cells Section
        *outFile << "\t\t" << implementedCell << " "
               << bitwiseOp << "(2) -> Cell(" << currentRow
               << "," << i << ")\n";
        *outFile << "\t\tMUX Mux(2,1,1) -> Cell(" << currentRow
               << "," << i << ")\n";

        //Map Section
        *outLiMMap   << "\t\tMemory(" << currentRow
                    << "," << i << ").RD -> " << bitwiseOp <<"("
                    << currentRow << "," << i << ").IN0\n";
        *outLiMMap   << "\t\tMux(" << currentRow
                    << "," << i << ").OUT0 -> " << bitwiseOp <<"("
                    << currentRow << "," << i << ").IN1\n";
        *outLiMMap   << "\t\tMemory(" << sourceCellsBaseIndex1 << "," << i
                    << ").RD -> Mux(" << currentRow << "," << i << ").IN0\n";
        *outLiMMap   << "\t\tMemory(" << sourceCellsBaseIndex2 << "," << i
                    << ").RD -> Mux(" << currentRow << "," << i << ").IN1\n";
    }
}

/// It prints the correct code for any MIXED lim cell
void PrintDexFile::printMIXED(std::string &bitwiseOp, int &currentRow,
    int* const &nameRow, int* const &nameSrc, std::list<std::string> &operators){

    // Support variable to store the Upper case string of bitwiseOp
    std::string implementedCell;

    // Support variable to store the row name
    std::string rowName="Mux_";

    // Out mux dimension
    int muxDimension=operators.size();

    // Counter for mux inputs
    int muxCount=0;

    if((muxDimension & (muxDimension-1))!=0)
    {
        // Error in the definition of the input mux: not a power of two!
        llvm_unreachable("Error in PrintDexFile: the mux of the LiM row is not properly defined!");
    }

    // Name of the Output pin of the source row
    std::string outSrc;

    std::string sourceCells;
    int sourceCellsBaseIndex;

    getNameAndIndexOfSourceRow(nameSrc, sourceCells, sourceCellsBaseIndex);

    // Check if the source cells are FAs/HAs:
    getOutPinName(sourceCells, outSrc);

    //Also here the parallelism should refer to
    //a configuration file
    for(int i=0; i<31; ++i){

        // If the first MSB is considered
        if(i==0){

            // Definition of the name of the row (concat of the operators at the input of the mux)
            for(std::list<std::string>::iterator tmpIT=operators.begin(); tmpIT!=operators.end(); ++tmpIT)
            {
                rowName=rowName+(*tmpIT);
                if(tmpIT!=std::next(operators.end(), -1))
                {
                    rowName=rowName+"_";
                }
            }
            insertNamesMap(nameRow, rowName, currentRow);
        }

        // Cells Section
        for(std::list<std::string>::iterator tmpIT=operators.begin(); tmpIT!=operators.end(); ++tmpIT)
        {
            implementedCell=*tmpIT;

            //Impose Upper case conditon to implementedCell
            transform(implementedCell.begin(), implementedCell.end(), implementedCell.begin(), ::toupper);

            *outFile << "\t\t" << implementedCell << " "
                    << *tmpIT << "(2) -> Cell(" << currentRow
                    << "," << i << ")\n";

            // Map Section up to mux input
            *outLiMMap   << "\t\tMemory(" << currentRow
                        << "," << i << ").RD -> " << *tmpIT << "("
                        << currentRow << "," << i << ").IN0\n";
            *outLiMMap   << "\t\tMemory(" << sourceCellsBaseIndex << "," << i
                        << ").RD -> " << *tmpIT << "(" << currentRow << ","
                        << i << ").IN1\n";
            *outLiMMap   <<"\t\t" << *tmpIT << "(" << currentRow << ","
                        << i << ").OUT0 -> Mux(" << currentRow
                        << "," << i << ").IN" << muxCount << "\n";
        }

        // Definition of the output multiplexer
        *outFile << "\t\tMUX Mux(" << muxDimension << ",1," << log2(muxDimension)
                << ") -> Cell(" << currentRow << "," << i << ")\n";

    }

}

/// It prints the correct code for any BITWISE lim cell
void PrintDexFile::printBITWISE(std::string &bitwiseOp, int &currentRow,
    int* const &nameRow, int* const &nameSrc){

    // Support variable to store the Upper case string of bitwiseOp
    std::string implementedCell=bitwiseOp;

    //Name of the Output pin of the source row
    std::string outSrc;

    std::string sourceCells;
    int sourceCellsBaseIndex;

    getNameAndIndexOfSourceRow(nameSrc, sourceCells, sourceCellsBaseIndex);

    //Check if the source cells are FAs/HAs:
    getOutPinName(sourceCells, outSrc);

    //Impose Upper case conditon to implementedCell
    transform(implementedCell.begin(), implementedCell.end(), implementedCell.begin(), ::toupper);

    insertNamesMap(nameRow, bitwiseOp, currentRow);
    
    //Cells Section
    *outFile << "\t\tfor i in range(0,1," << par-1 << "){ " << implementedCell
            << " " << bitwiseOp << "(2) -> Cell(" << currentRow << ",$i) }\n";

    //Map Section
    *outLiMMap   << "\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << currentRow << ",$i).RD -> " << bitwiseOp << "("
                << currentRow << ",$i).IN0 }\n";
    *outLiMMap   << "\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << sourceCellsBaseIndex << ",$i).RD -> " << bitwiseOp << "("
                << currentRow << ",$i).IN1 }\n";

}

/// It prints the correct code for an SUM lim cell with a 2to1 mux in input
/// so that 2 input bits for the logic are available.
void PrintDexFile::printADDMux2to1(int &currentRow, int* const &nameRow,
    int* const &nameSrc1, int* const &nameSrc2){

    std::string sourceCells1;
    int sourceCellsBaseIndex1;

    std::string sourceCells2;
    int sourceCellsBaseIndex2;

    //Name of the Output pin of the source rows
    std::string outSrc1;
    std::string outSrc2;

    getNameAndIndexOfSourceRow(nameSrc1, sourceCells1, sourceCellsBaseIndex1);
    getNameAndIndexOfSourceRow(nameSrc2, sourceCells2, sourceCellsBaseIndex2);

    //Check if the source cells are FAs/HAs:
    getOutPinName(sourceCells1, outSrc1);
    getOutPinName(sourceCells2, outSrc2);

    insertNamesMap(nameRow, "AddMux", currentRow);

    //Cells Section
    *outFile << "\t\tfor i in range(0,1," << par-2 << "){ FA Fa -> Cell("
                << currentRow << ",$i) }\n";
    *outFile << "\t\tHA Ha -> Cell(" << currentRow
                << "," << par-1 << ")\n";
    *outFile << "\t\tfor i in range(0,1," << par-1 << "){ MUX Mux(2,1,1) -> Cell("
                << currentRow << ",$i) }\n";
    
    //Map Section
    *outLiMMap << "\t\tfor i in range(0,1," << par-2 << "){ Memory("
                << currentRow << ",$i).RD -> Fa(" << currentRow << ",$i).A }\n";
    *outLiMMap << "\t\tMemory(" << currentRow << "," << par-1 << ").RD -> Ha("
                << currentRow << "," << par-1 << ").A\n";
    *outLiMMap << "\t\tfor i in range(0,1," << par-2 << "){ Mux(" << currentRow
                << ",$i).OUT0 -> Fa(" << currentRow << ",$i).B }\n";
    *outLiMMap << "\t\tMux(" << currentRow << "," << par-1 << ").OUT0 -> Ha("
                << currentRow << "," << par-1 << ").B\n";
    *outLiMMap << "\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << sourceCellsBaseIndex1 << ",$i).RD -> Mux(" << currentRow
                << ",$i).IN0 }\n";
    *outLiMMap << "\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << sourceCellsBaseIndex2 << ",$i).RD -> Mux(" << currentRow
                << ",$i).IN1 }\n";

    for(int i=0; i<par-2; i++)
        *outLiMMap << "\t\tFa(" << currentRow << "," << i << ").COUT -> Fa("
                    << currentRow << "," << i+1 << ").CIN\n";
    
    *outLiMMap << "\t\tFa(" << currentRow << "," << par-2 << ").COUT -> Ha("
                        << currentRow << "," << par-1 << ").CIN";

}

/// It prints the correct code for an SUM lim cell
void PrintDexFile::printADD(int &currentRow, int* const &nameRow,
    int* const &nameSrc){

    std::string sourceCells;
    int sourceCellsBaseIndex;

    //Name of the Output pin of the source row
    std::string outSrc;

    getNameAndIndexOfSourceRow(nameSrc, sourceCells, sourceCellsBaseIndex);

    //Check if the source cells are FAs/HAs:
    getOutPinName(sourceCells, outSrc);

    insertNamesMap(nameRow, "Add", currentRow);

    //Cells Section
    *outFile << "\t\tfor i in range(0,1," << par-2 << "){ FA Fa -> Cell("
                << currentRow << ",$i) }\n";
    *outFile << "\t\tHA Ha -> Cell(" << currentRow
                << "," << par-1 << ")\n";

    //Map Section
    *outLiMMap << "\t\tfor i in range(0,1," << par-2 << "){ Memory("
                << currentRow << ",$i).RD -> Fa(" << currentRow << ",$i).A }\n";
    *outLiMMap << "\t\tMemory(" << currentRow << "," << par-1 << ").RD -> Ha("
                << currentRow << "," << par-1 << ").A\n";
    *outLiMMap << "\t\tfor i in range(0,1," << par-2 << "){ Memory("
                << sourceCellsBaseIndex << ",$i).RD -> Fa(" << currentRow
                << ",$i).B }\n";
    *outLiMMap << "\t\tMemory(" << sourceCellsBaseIndex << "," << par-1
                << ").RD -> Ha(" << currentRow << "," << par-1 << ").B\n";

    for(int i=0; i<par-2; i++)
        *outLiMMap << "\t\tFa(" << currentRow << "," << i << ").COUT -> Fa("
                    << currentRow << "," << i+1 << ").CIN\n";
    
    *outLiMMap << "\t\tFa(" << currentRow << "," << par-2 << ").COUT -> Ha("
                        << currentRow << "," << par-1 << ").CIN";

}

/// It merges the source file into the destination file
/// The source file is closed if closeSource is true
void PrintDexFile::mergeToOutFile(raw_fd_ostream *destFD,
    raw_fd_ostream *sourceFD, std::string &sourceName, bool closeSourceFD) {

    char ch;

    // Declaration of tmp file in order to implement the merge operation
    std::fstream sourceFile;

    // Closing the file descriptor in order to be reopened in std C++
    (*sourceFD).close();

    sourceFile.open(sourceName, std::fstream::in);
    if ( !sourceFile.is_open() )
    {
        errs() << "Error opening file: " << sourceName << "\n";
        llvm_unreachable("Error in PrintDexFile::mergeToOutFile: unable to open a file.");
    }

    // Copy content from sourceFile to outFile
    while ( !sourceFile.eof() )
    {
        sourceFile >> std::noskipws >> ch;
        *destFD << ch;
    }

    sourceFile.close();


//Vedere cosa c'Ã¨ che non va e risolvere del perchÃ¨ dopo l'apertura del file la
//scrittura nel file non funziona; Ã¨ molto utile nel caso di power e 
//path instr
/*
    if ( closeSourceFD == false ) {
        // Reopenig llvm file descriptor
        std::error_code ErrorInfo; 
        sourceFD = new raw_fd_ostream(sourceName.c_str(), ErrorInfo, llvm::sys::fs::F_None);

        if (ErrorInfo){
            errs() << "Error opening file: " << sourceName << "\n";
            llvm_unreachable("Error in PrintDexFile: unable to create the .dex file.");
        }
        *sourceFD << "provaaaaaa\n";
    }        
*/

}

/// It reads the instructions and checks if the instruction is related
/// to the end of critical path
void PrintDexFile::powerPathSection() {

    // Used to recognize if there are more than one parallel path
    int i=0;

    // Iteration over the operation list
    for (FSM_ListIT=(FSMIT->second).begin(); FSM_ListIT!=(FSMIT->second).end();
        ++FSM_ListIT) {
        
        // Recovery information about the cell used by FSM
        limArrayIT=((*compArray).limArray).find(*FSM_ListIT);

        // The critical path end with a data storing in a memory cell,
        // so the memory input of the memory cell where we want to store
        // the data must be different from the default value (0xDEF) that
        // means no imput connection in memory cell
        if (((limArrayIT->second).inputConnections).front() != (int*)0xdef ){
            errs() << "Memory storing input: " << ((limArrayIT->second).inputConnections).front() << "\n";
            // Check if there are more instruction in parallel
            if(i>0)
                *outInstrPath << "\n\t\t\tbreak\n\n";

            printPowerPathSection();

            i++;
        }
    }
}

/// It identifies the kind of LiM and prints the power and path section
void PrintDexFile::printPowerPathSection() {

    // Information container
    std::string cell;
    int cellIndexWrite;
    int cellIndexRead;

    // Iterator of the cell which contains the logic to consider
    std::map<int * const, LiMArray::LiMRow>::iterator logicIT;

    // Get information about the store memory (end of critical path)
    getNameAndIndexOfSourceRow(*FSM_ListIT, cell, cellIndexWrite);

    // Find the memory row where it is contained the logic to consider
    logicIT=((*compArray).limArray).find(((limArrayIT->second).inputConnections).front());

    errs() << "\nLiM type: " << (logicIT->second).rowType << "\n";


    // If the number of input connection to the row is greater than 1, 
    // a mux has to be inserted inside the array
    bool isMux = (((logicIT->second).inputConnections).size()>2) ? true : false;

    std::string opType;

    int * const rowName=(logicIT->first);
    

    // Check if it is a recognized operation
    std::map<std::string, std::string>::const_iterator
        OpImplIT=LimOperations.find((logicIT->second).rowType);

    opType=OpImplIT->second;

    // "null" case shouldn't never happen
    if(opType=="null"){
        errs() << "A load operation is considered!\n";

        getNameAndIndexOfSourceRow(logicIT->first, cell, cellIndexRead);
        
        // Power section
        *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                        << cellIndexRead << ",$i) -> Read }\n";
        *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                        << cellIndexWrite << ",$i) -> Write }\n";

        // Path section
        *outInstrPath << "\t\t\tMemory(" << cellIndexRead << ",0) -> Read\n";
        *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";

    } else if(opType=="bitwise"){
        
        if(isMux) {
            printBITWISEMux2to1PowerPath(cellIndexWrite, rowName,
                *(std::next(((logicIT->second).inputConnections).begin(), 1)),
                ((logicIT->second).inputConnections).back());

        } else if ((logicIT->second).rowType=="switch"){
            // It is not implemented because it will be obsolete

        } else {

//######## START DEBUG ##############//

            //printBITWISEMux2to1PowerPath(cellIndexWrite, rowName,
            //                    *(std::next(((logicIT->second).inputConnections).begin(), 1)),
            //                    ((logicIT->second).inputConnections).back());
            //printADDPowerPath(cellIndexWrite, rowName,
            //            *(std::next(((logicIT->second).inputConnections).begin(),1)));
            //printADDMux2to1PowerPath(cellIndexWrite, rowName,
            //                *(std::next(((logicIT->second).inputConnections).begin(),1)),
            //                ((logicIT->second).inputConnections).back());

//######## END DEBUG ##############//

            printBITWISEPowerPath(cellIndexWrite, rowName,
                *(std::next(((logicIT->second).inputConnections).begin(),1)));

        }

    } else if(opType=="arith"){

        if(isMux) {
            printADDMux2to1PowerPath(cellIndexWrite, rowName,
                *(std::next(((logicIT->second).inputConnections).begin(),1)),
                ((logicIT->second).inputConnections).back());

        } else {
            printADDPowerPath(cellIndexWrite, rowName,
                *(std::next(((logicIT->second).inputConnections).begin(),1)));
        
        }

    } else {
        llvm_unreachable("Error in PrintDexFile: unknow operation returned from LimOperations.");
    }
}

/// It prints the correct code for any BITWISE lim cell in Power and Path Section
void PrintDexFile::printBITWISEPowerPath(int &cellIndexWrite, int* const &nameRow,
    int* const &nameSrc){

    std::string bitwiseOp;

    // Input index of the bitwise operator
    int cellIndexOutside;
    int cellIndexInside;

    // List of all inputs of the bitwise operator useful for the generation
    // of the critical path
    std::list <int> cellIndex;
    
    // Used to fill the method
    std::string sourceCells;

    // Get information about the inside memory input
    getNameAndIndexOfSourceRow(nameRow, bitwiseOp, cellIndexInside);
    cellIndex.push_back(cellIndexInside);

    // Get information about the outside memory input
    getNameAndIndexOfSourceRow(nameSrc, sourceCells, cellIndexOutside);
    cellIndex.push_back(cellIndexOutside);


    // Power section
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexInside << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexOutside << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ "
                    << bitwiseOp << "(" << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexWrite << ",$i) -> Write }\n";
    

    // Path section
    for(std::list <int>::iterator cellIndexIT=cellIndex.begin();
        cellIndexIT != cellIndex.end(); ++cellIndexIT) {
    
        if(cellIndexIT != cellIndex.begin())
            *outInstrPath << "\n\t\t\tbreak\n\n";

        *outInstrPath << "\t\t\tMemory(" << *cellIndexIT << ",0) -> Read\n";
        *outInstrPath << "\t\t\t" << bitwiseOp << "(" << cellIndexInside
                        << ",0)\n"; 
        *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";
    
    }

}

/// It prints the correct code for any BITWISE lim cell in Power and Path section
/// with a 2to1 mux in input so that 2 input bits for the logic are available.
///     (NOTE:Check the definition of the multiplexer!)
void PrintDexFile::printBITWISEMux2to1PowerPath(int &cellIndexWrite,
    int* const &nameRow, int* const &nameSrc1, int* const &nameSrc2){

    // Support variable to store the Upper case string of bitwiseOp
    std::string bitwiseOp;

    // Input index of the bitwise and mux2to1 operator
    int cellIndexOutside1;
    int cellIndexOutside2;
    int cellIndexInside;

    // List of all Outside inputs of the bitwise operator useful for the 
    // generation of the critical path
    std::list <int> cellIndexOutside;  

    // Used to fill the method
    std::string sourceCells1;
    std::string sourceCells2;

    // Get information about the inside memory input
    getNameAndIndexOfSourceRow(nameRow, bitwiseOp, cellIndexInside);

    // Get information about the outside memory inputs
    getNameAndIndexOfSourceRow(nameSrc1, sourceCells1, cellIndexOutside1);
    cellIndexOutside.push_back(cellIndexOutside1);
//######## START DEBUG ##############//
//    cellIndexOutside2=0x54;
//######## END DEBUG ################//
    getNameAndIndexOfSourceRow(nameSrc2, sourceCells2, cellIndexOutside2);
    cellIndexOutside.push_back(cellIndexOutside2);

    
    // Power section
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << cellIndexInside << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << cellIndexOutside1 << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                << cellIndexOutside2 << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ "
                    << bitwiseOp << "(" << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Mux(" 
                    << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexWrite << ",$i) -> Write }\n";

    
    // Path section
    *outInstrPath << "\t\t\tMemory(" << cellIndexInside << ",0) -> Read\n";
    *outInstrPath << "\t\t\t" << bitwiseOp << "(" << cellIndexInside
                        << ",0)\n"; 
    *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";

    for(std::list <int>::iterator cellIndexIT=cellIndexOutside.begin();
        cellIndexIT != cellIndexOutside.end(); ++cellIndexIT) {
    
        *outInstrPath << "\n\t\t\tbreak\n\n";

        *outInstrPath << "\t\t\tMemory(" << *cellIndexIT << ",0) -> Read\n";
        *outInstrPath << "\t\t\tMux(" << cellIndexInside << ",0)\n";
        *outInstrPath << "\t\t\t" << bitwiseOp << "(" << cellIndexInside
                        << ",0)\n"; 
        *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";
    
    }

}

/// It prints the correct code for an SUM lim cell in Power and Path section
void PrintDexFile::printADDPowerPath(int &cellIndexWrite, int* const &nameRow,
    int* const &nameSrc){
    
    // Input index of the bitwise operator
    int cellIndexOutside;
    int cellIndexInside;

    // Used to fill the method
    std::string arithOp;
    std::string sourceCells;

    // Get information about the inside memory input
    getNameAndIndexOfSourceRow(nameRow, arithOp, cellIndexInside);

    // Get information about the outside memory input
    getNameAndIndexOfSourceRow(nameSrc, sourceCells, cellIndexOutside);


    // Power section
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexInside << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexOutside << ",$i) -> Read }\n";              
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-2 << "){ Fa("
                    << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexWrite << ",$i) -> Write }\n";


    // In path section is considered the contamination time between FAs chain
    // because the focus is on the carry output of the FAs.
    // Instead in the last HA is considered the propagation time because the focus
    // is on the output.

    // Path section
    *outInstrPath << "\t\t\tMemory(" << cellIndexInside << ",0) -> Read\n";
    *outInstrPath << "\t\t\tfor i in range(0,1," << par-2 << ") { Fa("
                    << cellIndexInside << ",$i) -> Contamination }\n";
    *outInstrPath << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
    *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";
    
    *outInstrPath << "\n\t\t\tbreak\n\n";

    *outInstrPath << "\t\t\tMemory(" << cellIndexOutside << ",0) -> Read\n";
    *outInstrPath << "\t\t\tfor i in range(0,1," << par-2 << ") { Fa("
                    << cellIndexInside << ",$i) -> Contamination }\n";
    *outInstrPath << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
    *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";

}

/// It prints the correct code for an SUM lim cell in Power and Path section
/// with a 2to1 mux in input so that 2 input bits for the logic are available.
void PrintDexFile::printADDMux2to1PowerPath(int &cellIndexWrite, int* const &nameRow,
    int* const &nameSrc1, int* const &nameSrc2){
    
    // Input index of the FAs/HA and mux2to1 operator
    int cellIndexOutside1;
    int cellIndexOutside2;
    int cellIndexInside;

    // List of all Outside inputs of the FAs/Ha operator useful for the 
    // generation of the critical path
    std::list <int> cellIndexOutside;  

    // Used to fill the method
    std::string arithOp;
    std::string sourceCells1;
    std::string sourceCells2;

    // Get information about the inside memory input
    getNameAndIndexOfSourceRow(nameRow, arithOp, cellIndexInside);

    // Get information about the outside memory inputs
    getNameAndIndexOfSourceRow(nameSrc1, sourceCells1, cellIndexOutside1);
    cellIndexOutside.push_back(cellIndexOutside1);
//######## START DEBUG ##############//
//    cellIndexOutside2=0x54;
//######## END DEBUG ################//
    getNameAndIndexOfSourceRow(nameSrc2, sourceCells2, cellIndexOutside2);
    cellIndexOutside.push_back(cellIndexOutside2);


    // Power section
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexInside << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexOutside1 << ",$i) -> Read }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexOutside2 << ",$i) -> Read }\n";               
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-2 << "){ Fa("
                    << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Mux(" 
                    << cellIndexInside << ",$i) }\n";
    *outInstrPower << "\t\t\tfor i in range(0,1," << par-1 << "){ Memory("
                    << cellIndexWrite << ",$i) -> Write }\n";


    // In path section is considered the contamination time between FAs chain
    // because the focus is on the carry output of the FAs.
    // Instead in the last HA is considered the propagation time because the focus
    // is on the output.

    // Path section
    *outInstrPath << "\t\t\tMemory(" << cellIndexInside << ",0) -> Read\n";
    *outInstrPath << "\t\t\tfor i in range(0,1," << par-2 << ") { Fa("
                    << cellIndexInside << ",$i) -> Contamination }\n";
    *outInstrPath << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
    *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";
    
    for(std::list <int>::iterator cellIndexIT=cellIndexOutside.begin();
        cellIndexIT != cellIndexOutside.end(); ++cellIndexIT) {

        *outInstrPath << "\n\t\t\tbreak\n\n";

        *outInstrPath << "\t\t\tMemory(" << *cellIndexIT << ",0) -> Read\n";
        *outInstrPath << "\t\t\tMux(" << cellIndexInside << ",0)\n";
        *outInstrPath << "\t\t\tfor i in range(0,1," << par-2 << ") { Fa("
                        << cellIndexInside << ",$i) -> Contamination }\n";
        *outInstrPath << "\t\t\tHa(" << cellIndexInside << "," << par-1 << ")\n";
        *outInstrPath << "\t\t\tMemory(" << cellIndexWrite << ",0) -> Write\n";
    }

}


///////////////////////////////////////////////////////////////////////////
// From older version of this file ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/// It generates the unique name for the each component: FUTURE IMPLEMENTATION
//int PrintDexFile::getIndex(std::string operation){

//    componentCntIT=componentCnt.find(operation);

//    if(componentCntIT!=componentCnt.end())
//    {
//        (componentCntIT->second)+=1;
//        return (componentCntIT->second);
//    } else {
//        componentCnt.insert({operation,0});
//        return 0;
//    }
//}

/// It prints the correct code for an SUB lim cell: CRITICAL, there's the need
/// of an additional bit as CIN. The sub is converted into an addition by the
/// preceding passes.
//void PrintDexFile::printSUB(int * currentRow, int **nameRow, int **nameSrc){

//    std::string sourceCells;
//    int sourceCellsBaseIndex;

//    getNameAndIndexOfSourceRow(nameSrc, &sourceCells, &sourceCellsBaseIndex);

//    //Also here the parallelism should refer to
//    //a configuration file
//    for(int i=0; i<31; ++i){

//        //If the first MSB is considered
//        if(i==0){
//            insertNamesMap(nameRow, "Sub", currentRow);
//        }

//        //Cells Section
//        Output << "\t\tFA Fa -> Cell(" << (*currentRow)
//               << "," << i << ")\n";

//        //Map Section
//        //Supposing (IN0=a, IN1=b, CIN=carry, OUT=SUM, COUT= carry out): CHECK!
//        OutputLiMMap << "\t\tMemory(" << (*currentRow)
//                     << "," << i << ").RD -> Fa("
//                     << (*currentRow) << "," << i << ").IN0\n";
//        OutputLiMMap << "\t\t" << sourceCells << "("
//                     << sourceCellsBaseIndex << ","
//                     << i << ").OUT -> Fa("
//                     << (*currentRow) << "," << i
//                     << ").IN1\n";
//        OutputLiMMap << "\t\tFa(" << (*currentRow)
//                     << "," << (i-1) << ").COUT -> Fa("
//                     << (*currentRow) << "," << i
//                     << ").CIN\n";
//    }

//}