// Standard C++ Include Files
#include <cmath>
#include <fstream>
#include <iostream>
#include <system_error>

// Debug
#include <stdexcept>

// LLVM include files
#include "PrintVhdlFile.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/FileSystem.h"

using namespace octantis;
using namespace llvm;

/// It prints the .vhd file for both the memory entity and its testbench
void PrintVhdlFile::print() {

    // declaration of the output .vhd file
    std::string outFileName = "ComponentName.vhd";

    // error handling section
    std::error_code ErrorInfo;

    outFile =
            new raw_fd_ostream(outFileName.c_str(), ErrorInfo, llvm::sys::fs::F_None);
    if (ErrorInfo) {
        errs() << "Error opening file: " << outFileName << "\n";
        llvm_unreachable("Error in PrintVhdlFile: unable to create the .vhd file.");
    }

    // first part of the .vhd file
    *outFile << "--#-----------------------------------------------#\n"
             << "--# .vhd file generated by Octantis tool #\n"
             << "--#-----------------------------------------------#\n\n\n";

    // Printing the content of the different sections for the entity: Libraries, Entity and Architecture
    // Printing also the associated testbench
    printLib();
    printEntity();
    printArchitecture();
    printTestbench();

    // Closing the file
    (*outFile).close();

    errs() << "Octantis: end .vhd file generation process!\n\n";
}

/// This function prints the imported libraries declaration part
void PrintVhdlFile::printLib() {
    *outFile << "-- Imported libraries section\n"
             << "library ieee;\n"
             << "use ieee.numeric_std.all;\n"
             << "use ieee.std_logic_1164.all;\n\n\n";
}

/// It is the function devoted to the printing of the ENTITY declaration part
/// inside the .vhd file
void PrintVhdlFile::printEntity() {

    // printing the ENTITY section

    /*
      The memory parallelism and number of words are set based on par and entries member variables.
      As regards I/O signals, a clock and a reset (active high) are present. If EN (enable) is high and
      READNOTWRITE is high, a read operation is performed. If EN (enable) is high and
      READNOTWRITE is low, a write operation is performed. When GO is at '1' for one clock cycle,
      it means that all inputs have been inserted inside the memory and it can start carrying out its
      algorithm. The memory asserts DONE ('1') when results have been gathered inside their related memory
      rows. DATA_IN and DATA_OUT are the buses for input and output data.
    */
    *outFile
            << "entity EntityName is\n"
            << "\tgeneric(\n"
            << "\t\tword_size: natural := " << par << ";\n"
            << "\t\tentries: natural := " << entries << ");\n"
            << "\tport(\n";

    *outFile << "\t\tRST : in std_logic;\n"
             << "\t\tCLK : in std_logic;\n"
             << "\t\tEN : in std_logic;\n"
             << "\t\tREADNOTWRITE : in std_logic;\n"
             << "\t\tGO : in std_logic;\n"
             << "\t\tDONE : out std_logic;\n"
             << "\t\tADDRESS : in std_logic_vector(" << par << " - 1 downto 0);\n"
             << "\t\tDATA_IN : in std_logic_vector(" << par << " - 1 downto 0);\n"
             << "\t\tDATA_OUT : out std_logic_vector(" << par << " - 1 downto 0));\n";

    // ending the entity section;
    *outFile << "end EntityName;\n\n";
}

/// It is the function devoted to the printing of the ARCHITECTURE part
/// inside the .vhd file
void PrintVhdlFile::printArchitecture() {

    // Components declaration support file
    std::string compDecName = ".compDec.vhd";
    std::error_code ErrorInfoCompDec;
    compDec = new raw_fd_ostream(compDecName.c_str(), ErrorInfoCompDec,
                                 llvm::sys::fs::F_None);
    if (ErrorInfoCompDec) {
        errs() << "Error opening file: " << compDecName << "\n";
        llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
    }

    // Signals declaration support file
    std::string sigDecName = ".sigDec.vhd";
    std::error_code ErrorInfoSigDec;
    sigDec = new raw_fd_ostream(sigDecName.c_str(), ErrorInfoSigDec,
                                llvm::sys::fs::F_None);
    if (ErrorInfoSigDec) {
        errs() << "Error opening file: " << sigDecName << "\n";
        llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
    }

    // Components instantiation support file
    std::string compInstName = ".compInst.vhd";
    std::error_code ErrorInfoCompInst;
    compInst = new raw_fd_ostream(compInstName.c_str(), ErrorInfoCompInst,
                                  llvm::sys::fs::F_None);
    if (ErrorInfoCompInst) {
        errs() << "Error opening file: " << compInstName << "\n";
        llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
    }

    // Architecture part begins
    *compDec << "architecture struct of EntityName is\n";

    // declaring a type that will be used to instatiate the memory array
    *sigDec << "\ttype Mem_array is array (0 to " << entries << " - 1) of std_logic_vector(" << par
            << " - 1 downto 0);\n";

    *sigDec << "\tsignal Mem: Mem_array;\n";

    // printing the needed processes
    printProcesses(compInst, sigDec);


    // operand type defined in LimOperations of OperationsImplemented (value field)
    std::string opType;
    // operator defined in LimOperations of OperationsImplemented (key field)
    std::string op;
    // source Row whose output is connected to the Memory Cells of the currentRow
    int *srcRow1;
    // source Row whose output is connected to the internal logic (bitwise_operator/FA/HA/MUX21) of the currentRow
    int *srcRow2;
    // source Row whose output is connected to the internal logic (bitwise_operator/FA/HA/MUX21) of the currentRow
    int *srcRow3;
    // true if a MUX21 is needed
    bool isMux;
    // true if a MUX21 is needed, but this variable will be used in order to insert its declaration
    // in the component declaration part
    bool isMux21Present = false;
    // true if an addition is present, used in order to declare HA and FA in the component declaration section
    bool isAddPresent = false;
    // list containing all the sizes of the other muxes needed (switch case)
    std::list<int> otherMuxesWidth;
    // useful in order to know if an equal mux size has already been found
    bool elFound = false;

    // input connection type to distinguish between "OLiM" and "OC"
    std::string inputConnectionTypeSrc2, inputConnectionTypeSrc3;

    // Cycling over the limArray which is a map whose mapped value field is a
    // LiMRow
    for (limArrayIT = ((*compArray).limArray).begin();
         limArrayIT != ((*compArray).limArray).end(); ++limArrayIT) {

        // If the number of input connection to the row is greater than 1,
        // a mux has to be inserted inside the array
        isMux = (((limArrayIT->second).inputConnections).size() > 2) ? true : false;

        // retrieving the name of the current row from the key field of the limArray map
        int *const rowName = (limArrayIT->first);

        // string that completes the string reffering to the signal given in input
        // to a limCell it will be "_OUT" when the srcRow1 is another limRow,
        // "_input" if the signal is an input one
        std::string limRowInputcomp;

        // checking if the operation relative to the LiMRow is present in the set of
        // possible operations
        std::map<std::string, std::string>::const_iterator OpImplIT =
                LimOperations.find((limArrayIT->second).rowType);

        // Check if it is a recognized operation
        if (OpImplIT != LimOperations.end()) {

            // opType refers to the operation type defined in OperationsImplemented.h,
            // that is to say null, bitwise, arith, while op refers to the instruction
            // itself, such as load, xor, etc...
            opType = OpImplIT->second;
            op = OpImplIT->first;

            if (opType == "null") {

                // Source or Result memory Row

                // signal representing the data read from the current row memory cells and given
                // in input to the current row logic
                *sigDec << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
                        << "- 1 downto 0);\n";

            } else if (opType == "bitwise") {

                // check if input 2to1 mux is needed
                if (isMux) {
                    // it will be needed to add the MUX21 declaration
                    isMux21Present = true;
                    // source row 1
                    srcRow1 =
                            isInputRow((((limArrayIT->second).inputConnections).front()))
                            ? rowName
                            : (((limArrayIT->second).inputConnections).front());
                    // source row 2
                    srcRow2 =
                            *(std::next(((limArrayIT->second).inputConnections).begin(), 1));
                    // source row 3
                    srcRow3 = (((limArrayIT->second).inputConnections).back());

                    inputConnectionTypeSrc2 = *(std::next(((limArrayIT->second).inputConnectionsType).begin(), 1));
                    inputConnectionTypeSrc3 = ((limArrayIT->second).inputConnectionsType).back();

                    printBitwiseMux2to1(op, rowName, srcRow1, inputConnectionTypeSrc2, inputConnectionTypeSrc3,
                                        srcRow2, srcRow3, sigDec, compInst);

                    // check if multiple logic operators are needed
                } else if ((limArrayIT->second).rowType == "switch") {
                    // source row 1
                    srcRow1 =
                            isInputRow((((limArrayIT->second).inputConnections).front()))
                            ? rowName
                            : (((limArrayIT->second).inputConnections).front());
                    // source row 2
                    srcRow2 =
                            *(std::next(((limArrayIT->second).inputConnections).begin(), 1));


                    inputConnectionTypeSrc2 = *(std::next(((limArrayIT->second).inputConnectionsType).begin(), 1));

                    // cycling over the muxes size list in order to check if the current one has already been found
                    for (std::list<int>::iterator listIT = otherMuxesWidth.begin();
                         listIT != otherMuxesWidth.end(); ++listIT) {
                        if (*listIT == (int) (((limArrayIT->second).additionalLogic).size())) {
                            elFound = true;
                        }
                    }

                    // if the same mux size has already been found, the current one must not be pushed in the list
                    if (!elFound) {
                        otherMuxesWidth.push_back(((limArrayIT->second).additionalLogic).size());
                    }
                    elFound = false;

                    printMixed(op, rowName, srcRow1, srcRow2, inputConnectionTypeSrc2,
                               (limArrayIT->second).additionalLogic, sigDec, compInst);

                } else {

                    // printBITWISE
                    srcRow1 =
                            isInputRow((((limArrayIT->second).inputConnections).front()))
                            ? rowName
                            : (((limArrayIT->second).inputConnections).front());
                    srcRow2 =
                            *(std::next(((limArrayIT->second).inputConnections).begin(), 1));


                    inputConnectionTypeSrc2 = *(std::next(((limArrayIT->second).inputConnectionsType).begin(), 1));

                    printBitwise(rowName, srcRow1, srcRow2, inputConnectionTypeSrc2, op, sigDec,
                                 compInst);
                }

            } else if (opType == "arith") {
                // it will be needed to add the FA/HA declaration
                isAddPresent = true;

                //Shift amount
                int shiftAmt;

                //Check if the operation is an add
                if (op == "add") {
                    // check if an input 2to1 mux is needed
                    if (isMux) {
                        // it will be needed to add the MUX21 declaration
                        isMux21Present = true;

                        // source row 1
                        srcRow1 =
                                isInputRow((((limArrayIT->second).inputConnections).front()))
                                ? rowName
                                : (((limArrayIT->second).inputConnections).front());
                        // source row 2
                        srcRow2 =
                                *(std::next(((limArrayIT->second).inputConnections).begin(), 1));
                        // source row 3
                        srcRow3 = (((limArrayIT->second).inputConnections).back());

                        inputConnectionTypeSrc2 = *(std::next(((limArrayIT->second).inputConnectionsType).begin(), 1));
                        inputConnectionTypeSrc3 = ((limArrayIT->second).inputConnectionsType).back();

                        printAddMux2to1(rowName, srcRow1, inputConnectionTypeSrc2, inputConnectionTypeSrc3, srcRow2,
                                        srcRow3,
                                        sigDec, compInst);

                    } else {

                        // source row 1
                        srcRow1 =
                                isInputRow((((limArrayIT->second).inputConnections).front()))
                                ? rowName
                                : (((limArrayIT->second).inputConnections).front());
                        // source row 2
                        srcRow2 =
                                *(std::next(((limArrayIT->second).inputConnections).begin(), 1));

                        inputConnectionTypeSrc2 = *(std::next(((limArrayIT->second).inputConnectionsType).begin(), 1));

                        printAdd(rowName, srcRow1, srcRow2, inputConnectionTypeSrc2, sigDec,
                                 compInst);
                    }
                } else if (op == "sdiv") {
                    // source row 1
                    srcRow1 =
                            isInputRow((((limArrayIT->second).inputConnections).front()))
                            ? rowName
                            : (((limArrayIT->second).inputConnections).front());

                    //Retrieving shift amount from the first location of the additionalLogic field
                    shiftAmt = stoi(((limArrayIT->second).additionalLogic).front());

                    printShiftRight(rowName, srcRow1, srcRow2, limRowInputcomp, sigDec,
                                    compInst);

                }


            } else {
                llvm_unreachable(
                        "Error in PrintVhdlFile: unknow operation returned from "
                        "LimOperations.");
            }

        } else {
            llvm_unreachable("Error in PrintVhdlFile: unknown compiled operation. "
                             "The name is not present inside LimOperations map.");
        }
    }


    // if a MUX21 is needed, it must be declared
    if (isMux21Present) {
        *compDec << "\tcomponent MUX21 is\n"
                 << "\t\tport(\n"
                 << "\t\tA: in std_logic_vector(NBIT - 1 downto 0);\n"
                 << "\t\tB: in std_logic_vector(NBIT - 1 downto 0);\n"
                 << "\t\tSEL: in std_logic;\n"
                 << "\t\tY: out std_logic_vector(NBIT - 1 downto 0));\n"
                 << "\t end component;\n\n";
    }

    // if an ADD is needed, FA/HA must be declared
    if (isAddPresent) {
        *compDec << "\tcomponent RCA is\n"
                 << "\t\tgeneric(NBIT: integer);\n"
                 << "\t\tport(\n"
                 << "\t\tA: in std_logic_vector(NBIT - 1 downto 0);\n"
                 << "\t\tB: in std_logic_vector(NBIT - 1 downto 0);\n"
                 << "\t\tCin: in std_logic;\n"
                 << "\t\tS: out std_logic_vector(NBIT - 1 downto 0);\n"
                 << "\t\tCout: out std_logic);\n"
                 << "\t end component;\n\n";
    }

    // cycling over the list of mux sizes
    for (std::list<int>::iterator listIT = otherMuxesWidth.begin(); listIT != otherMuxesWidth.end(); ++listIT) {
        // foreach size a mux must be declared inside the component declaration section
        *compDec << "\tcomponent MUX" << *listIT << "1 is\n"
                 << "\t\tport(\n";

        // inserting new pins
        for (int i = 0; i < *listIT; i++) {
            *compDec << "\t\tIN_" << i << ": in std_logic;\n";
        }

        // declaring the selection signal with a parallelism which is log2 od the mux dimension
        *compDec << "\t\tSEL: in std_logic_vector(" << (int) (log2(*listIT)) << " - 1 downto 0);\n"
                 << "\t\tY: out std_logic);\n" << "\t end component;\n\n";
    }

    *sigDec << "\nbegin\n\n";
    *compInst << "\nend struct;\n";
    // The content of compDec will be copied into outFile and will be closed
    mergeToOutFile(outFile, compDec, compDecName, true);

    // The content of sigDec will be copied into outFile and will be closed
    mergeToOutFile(outFile, sigDec, sigDecName, true);

    // The content of compInst will be copied into outFile and will be closed
    mergeToOutFile(outFile, compInst, compInstName, true);

}

/// It returns true if the input LiMRow is has an input which is not the output of another LiMRow
bool PrintVhdlFile::isInputRow(int *const &rowName) {
    return (rowName == (int *) 0xdef) ? true : false;
}

/// It merges the source file into the destination file
/// The source file is closed if closeSource is true
void PrintVhdlFile::mergeToOutFile(raw_fd_ostream *destFD,
                                   raw_fd_ostream *sourceFD,
                                   std::string &sourceName,
                                   bool closeSourceFD) {

    char ch;

    // Declaration of tmp file in order to implement the merge operation
    std::fstream sourceFile;

    // Closing the file descriptor in order to be reopened in std C++
    (*sourceFD).close();

    sourceFile.open(sourceName, std::fstream::in);
    if (!sourceFile.is_open()) {
        errs() << "Error opening file: " << sourceName << "\n";
        llvm_unreachable(
                "Error in PrintDexFile::mergeToOutFile: unable to open a file.");
    }

    // Copy content from sourceFile to outFile
    while (!sourceFile.eof()) {
        sourceFile >> std::noskipws >> ch;
        *destFD << ch;
    }

    sourceFile.close();
}

/// It prints the correct code for any BITWISE lim cell
void PrintVhdlFile::printBitwise(int *const &rowName, int *const &srcRow1,
                                 int *const &srcRow2, std::string &inputConnectionType,
                                 std::string &bitwiseOp,
                                 raw_fd_ostream *const &sigFd,
                                 raw_fd_ostream *const &compFd) {
    // declaration of the intermediate signals:
    // signal representing the
    // data read from the current row memory cells and given
    // in input to the current row logic
    *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // generate statement in which the output of the current LiM row is assigned according to the logic operator
    if (inputConnectionType == "OLiM") {
        *compFd << "\t-- Bitwise\n"
                //<< "\tROW_" << rowName << "_GEN: for i in 0 to " << par
                //<< " - 1 generate\n"

                << "\tROW_" << rowName << "_OUT <= "
                << "ROW_" << rowName << "_MEM_RD " << bitwiseOp << " ROW_"
                << srcRow2 << "_OUT;\n";
        //<< "\tend generate;\n\n";
    } else if (inputConnectionType == "OC") {
        *compFd << "\t-- Bitwise\n"
                << "\tROW_" << rowName << "_OUT <= "
                << "ROW_" << rowName << "_MEM_RD " << bitwiseOp << " ROW_"
                << srcRow2 << "_MEM_RD;\n";
        //<< "\tend generate;\n\n";
    }
}

/// It prints the correct code for any MIXED lim cell
void PrintVhdlFile::printMixed(std::string &bitwiseOp, int *const &rowName,
                               int *const &srcRow1, int *const &srcRow2,
                               std::string &inputConnectionType,
                               std::list<std::string> &operators,
                               raw_fd_ostream *const &sigFd,
                               raw_fd_ostream *const &compFd) {

    // Out mux dimension
    int muxDimension = operators.size();

    // Counter for mux inputs
    int muxCount = 0;

    if ((muxDimension & (muxDimension - 1)) != 0) {
        // Error in the definition of the input mux: not a power of two!
        llvm_unreachable("Error in PrintDexFile: the mux of the LiM row is not "
                         "properly defined!");
    }

    // declaration of the intermediate signals:
    // signal representing the data read from the current row memory cells
    // and given in input to the current row logic
    *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << " - 1 downto 0);\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << " - 1 downto 0);\n";

    // signal representing the selection signal of the inner mux
    *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic_vector("
           << (int) (log2(muxDimension)) << " - 1 downto 0);\n";

    // check if operand is from source row
    *compFd //<< "\tROW_" << rowName << "_GEN: for i in 0 to " << par
            //<< " - 1 generate\n"

            << "\t MUX_" << rowName << "_PM: MUX21 port map(";

    // assigning signals to the various pins of the mux
    for (auto listIT = operators.begin(); listIT != operators.end(); listIT++) {
        *compFd << "IN_" << muxCount << " => "
                << "ROW_" << rowName << "_OP" << muxCount << "_OUT, ";
        ++muxCount;
    }

    // assigning the selection signal
    *compFd << "SEL"
            << " => "
            << "ROW_" << rowName << "_SEL, "
            << "Y => ROW_" << rowName << "_OUT);\n";

    muxCount = 0;

    // assigning the various output signals of the operators
    for (auto listIT = operators.begin(); listIT != operators.end(); listIT++) {

        *compFd << "\t\tROW_" << rowName << "_OP" << muxCount << "_OUT <= "
                << "ROW_" << rowName << "_MEM_RD(i) " << *listIT << " ROW_" << srcRow2;

        if (inputConnectionType == "OLiM") {
            *compFd << "_OUT;\n";
        } else if (inputConnectionType == "OC") {
            *compFd << "_MEM_RD;\n";
        }

        // signal representing the output data of the internal operator and must be added to the declaration section
        *sigFd << "\tsignal ROW_" << rowName << "_OP" << muxCount
               << "_OUT: std_logic_vector(" << par << "- 1 downto 0);\n";

        ++muxCount;
    }

    *compFd << "\tend generate;\n\n";
}

/// It prints the correct code for any BITWISE lim cell with a 2to1 mux in
/// input
/// so that 2 input bits for the logic are available.
void PrintVhdlFile::printBitwiseMux2to1(
        std::string &bitwiseOp, int *const &rowName, int *const &srcRow1,
        std::string &inputConnectionType1, std::string &inputConnectionType2, int *const &srcRow2, int *const &srcRow3,
        raw_fd_ostream *const &sigFd, raw_fd_ostream *const &compFd) {
    // declaration of the intermediate signals:
    // signal representing the data read from the current row memory cells
    // and given in input to the current row logic
    *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the selection signal of the mux of the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic;\n";

    // signal representing the output data of the internal 2-to-1 mux of
    // the LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_MUX_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // generate statement in which mux ports are assigned and also the output of the LiM row assigned according to thelogic operator
    *compFd //<< "\tROW_" << rowName << "_GEN: for i in 0 to " << par
            //<< " - 1 generate\n"

            << "\tMUX_" << rowName << "_PM: MUX21 port map(A => ROW_" << srcRow2;

    if (inputConnectionType1 == "OLiM") {
        *compFd << "_OUT, ";
    } else if (inputConnectionType1 == "OC") {
        *compFd << "_MEM_RD, ";
    }

    *compFd << "B => ROW_" << srcRow3;

    if (inputConnectionType2 == "OLiM") {
        *compFd << "_OUT, ";
    } else if (inputConnectionType2 == "OC") {
        *compFd << "_MEM_RD, ";
    }

    *compFd << "SEL => "
            << "ROW_" << rowName << "_SEL,"
            << "Y => ROW_" << rowName << "_MUX_OUT);\n"

            << "\tROW_" << rowName << " <= "
            << "ROW_" << rowName << "_MEM_RD " << bitwiseOp << " ROW_" << rowName
            << "_MUX_OUT;\n\n";
    //<< "\tend generate;\n\n";
}

/// It prints the correct code for an SUM lim cell with a 2to1 mux in input
/// so that 2 input bits for the logic are available.
void PrintVhdlFile::printAddMux2to1(int *const &rowName, int *const &srcRow1,
                                    std::string &inputConnectionType1, std::string &inputConnectionType2,
                                    int *const &srcRow2, int *const &srcRow3,
                                    raw_fd_ostream *const &sigFd,
                                    raw_fd_ostream *const &compFd) {
    // declaration of the intermediate signals:
    // signal representing the data read from the current row memory cells
    // and given in input to the current row logic
    *sigFd << "s\tignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the selection signal of the mux of the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_SEL: std_logic;\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the carry out chain
    *sigFd << "\tsignal ROW_" << rowName << "_COUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the output data of the internal 2-to-1 mux of
    // the LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_MUX_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // generate statement in which the add operation is carried out and the mux ports are assigned
    *compFd << "\t-- Add mixed\n"
            //<< "\tROW_" << rowName << "_GEN: for i in 0 to" << par
            //<< " - 1 generate\n"

            << "\tMUX" << rowName << "i_PM: MUX21 port map(A => ROW_" << srcRow2;

    if (inputConnectionType1 == "OLiM") {
        *compFd << "_OUT, ";
    } else if (inputConnectionType1 == "OC") {
        *compFd << "_MEM_RD, ";
    }

    *compFd << "B => ROW_" << srcRow3;

    if (inputConnectionType2 == "OLiM") {
        *compFd << "_OUT, ";
    } else if (inputConnectionType2 == "OC") {
        *compFd << "_MEM_RD, ";
    }

    *compFd << "SEL => "
            << "ROW_" << rowName << "_SEL,"
            << " Y => ROW_" << rowName << "_MUX_OUT);\n "

            << "\tRCA_PM: RCA port map(A => ROW_" << rowName
            << "_MEM_RD, B => ROW_" << rowName << "_MUX_OUT, Cin => '0', Cout => ROW_" << rowName
            << "_COUT, S => ROW_" << rowName << "_OUT);\n";
    //<< "\tend generate;\n";
}

/// It prints the correct code for an SUM lim cell
void PrintVhdlFile::printAdd(int *const &rowName, int *const &srcRow1,
                             int *const &srcRow2, std::string &inputConnectionType,
                             raw_fd_ostream *const &sigFd,
                             raw_fd_ostream *const &compFd) {
    // declaration of the intermediate signals:
    // signal representing the data read from the current row memory cells
    // and given in input to the current row logic
    *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the carry out chain
    *sigFd << "\tsignal ROW_" << rowName << "_COUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // generate statement in which the add operation is carried out
    *compFd << "\t-- Add\n"
            //<< "\tROW_" << rowName << "_GEN: for i in 0 to " << par
            //<< " - 1 generate\n"

            //<< "\t\tROW_" << rowName << "_IF1: if i /= 0 generate\n"
            << "\t\t\tRCA_" << rowName << "_PM: RCA port map(A => ROW_" << rowName
            << "_MEM_RD, B => ROW_" << srcRow2;

    if (inputConnectionType == "OLiM") {
        *compFd << "_OUT, \n";
    } else if (inputConnectionType == "OC") {
        *compFd << "_MEM_RD, \n";
    }


    *compFd << "Cin => '0', Cout => ROW_" << rowName
            << "_COUT, S => ROW_" << rowName << "_OUT);\n";
    //<< "\t\tend generate;\n\n"
    //<< "\tend generate;\n\n";
}

/// It prints the correct code for a right shift lim cell
void PrintVhdlFile::printShiftRight(int *const &rowName, int *const &srcRow1, int *const &srcRow2,
                                    std::string &limRowComp, raw_fd_ostream *const &sigFd,
                                    raw_fd_ostream *const &compFd) {

    // declaration of the intermediate signals:
    // signal representing the data read from the current row memory cells
    // and given in input to the current row logic
    *sigFd << "\tsignal ROW_" << rowName << "_MEM_RD: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    // signal representing the data in output from the current LiMRow
    *sigFd << "\tsignal ROW_" << rowName << "_OUT: std_logic_vector(" << par
           << "- 1 downto 0);\n";

    *compFd << "\tROW_" << rowName << "_OUT <= " << "ROW_" << rowName << "_MEM_RD;\n";

}


/// It is useful to get the total number of data that must be retrieved from the outside and written into the memory before starting the algoritm execution
std::string PrintVhdlFile::getNumberInputs() {
    int numberInputs = 0;

    for (auto mapIT = ((*compArray).limArray).begin(); mapIT != ((*compArray).limArray).end(); ++mapIT) {
        if (isInputRow((((mapIT->second).inputConnections).front()))) {
            numberInputs++;
        }
    }

    return std::to_string(numberInputs);
}

/// It is useful in order to know the amount of data that can be read once the algorithm has finished
std::string PrintVhdlFile::getNumberOutputs() {
    int numberOutputs = 0;
    bool flag = true;

    for (auto mapIT = ((*compArray).limArray).begin(); mapIT != ((*compArray).limArray).end(); ++mapIT) {
        if ((mapIT->second).rowType == "load") {

            for (auto it = ((*compArray).limArray).begin(); it != ((*compArray).limArray).end(); ++it) {
                for (auto listIT = ((it->second).inputConnections).begin();
                     listIT != ((it->second).inputConnections).end(); ++listIT) {
                    if (mapIT->first == *listIT) {
                        flag = false;
                    }
                }
            }

            if (flag) {
                numberOutputs++;
                if (std::find(resultRowList.begin(), resultRowList.end(), mapIT->first) == resultRowList.end()) {
                    resultRowList.push_back(mapIT->first);
                }
            }

            flag = true;

        }
    }

    return std::to_string(numberOutputs);
    //return std::to_string(compArray->nOutputs);
}


/// It prints the series of processes needed in order to properly carry out writing and reading operations, but also the entire algorithm
void PrintVhdlFile::printProcesses(raw_fd_ostream *const &compFd, raw_fd_ostream *const &sigFd) {
    std::stringstream rowAddr;

    // fixed process that specifies the reading and writing protocol for the memory
    // both are synchronous
    std::string fixed_proc =
            "\trd_proc: process (CLK, RST)\n"
            "\t\tbegin\n"
            "\t\t\tif (EN = '1') then  \n"
            "\t\t\t\tif READNOTWRITE = '1' and (CLK'event and CLK = '1') then\n"
            "\t\t\t\t\tdata_out <= Mem(to_integer(unsigned(address)));\n"
            "\t\t\t\tend if;\n"
            "\t\t\tend if;\n"
            "\tend process;\n\n"
            "\twrt_proc: process (CLK, RST)\n"
            "\t\tbegin\n"
            "\t\t\tif (RST = '1') then\n"
            "\t\t\t\tMem <= (others =>(others =>'0'));\n"
            "\t\t\telsif (EN = '1') then  \n"
            "\t\t\t\tif READNOTWRITE = '0' and (CLK'event and CLK = '1') then\n"
            "\t\t\t\t\tMem(to_integer(unsigned(address))) <= data_in;\n"
            "\t\t\t\tend if;\n"
            "\t\t\telse\n";

    // printing the previous process into the file
    *compFd << fixed_proc;

    bool firstEnter = true;

    std::list<int *> firstEnteredShift;

    /*
      cycling over the FSM structure in order to complete the previous fixed part of the process with
      a variable part in which the memory rows to be written during the algorithm execution are specified. The
      writing of rows can happen only at Ti where i is an odd number
    */
    for (FSMIT = ((*compFSM).FSM).begin(); FSMIT != ((*compFSM).FSM).end(); ++FSMIT) {

        // avoiding considering the list of rows associated to the time 0 because they are written by the external testbench
        if (FSMIT->first != 0) {

            // setting firstEnter to true
            firstEnter = true;

            // cycling over the list of operations to be performed during the current FSM time
            for (FSM_ListIT = (FSMIT->second).begin(); FSM_ListIT != (FSMIT->second).end(); ++FSM_ListIT) {

                // if firstEnter is true, an if or elsif statement must be added
                if (firstEnter) {

                    // if it is the first time printing a statement, an if statement is needed, an elsif one otherwise
                    if (FSMIT->first == 1) {
                        *compFd << "\t\t\t\tif (T" << (FSMIT->first) * 2 - 1 << " = '1') then\n";
                    } else {
                        *compFd << "\t\t\t\telsif (T" << (FSMIT->first) * 2 - 1 << " = '1') then\n";
                    }
                    // setting firstEnter to false in order not to print 2 subsequent if or elsif
                    firstEnter = false;
                }

                // recover information about the cell used by FSM
                limArrayIT = ((*compArray).limArray).find(*FSM_ListIT);

                // writing to rowAddr the row name got from the current iterator
                rowAddr << *FSM_ListIT;
                // printing the write statement for the memory location pointed by rowAddr/4.
                // It is assigned the signal specified by the first element of its inputConnections list (the one entering the proper memory cell)

                std::string shiftType = "sdiv";

                if (compArray->isLiMRowOfThisType(*FSM_ListIT, shiftType)) {
                    if (std::find(firstEnteredShift.begin(), firstEnteredShift.end(), *FSM_ListIT) ==
                        firstEnteredShift.end()) {
                        *compFd << "\t\t\t\t\tMem(" << std::stoi(rowAddr.str(), 0, 16) / 4 << ") <= ROW_"
                                << ((limArrayIT->second).inputConnections).front() << "_OUT;\n";
                        firstEnteredShift.push_back(*FSM_ListIT);
                    } else {
                        *compFd << "\t\t\t\t\tMem(" << std::stoi(rowAddr.str(), 0, 16) / 4 << ") <= '0' & ROW_"
                                << *FSM_ListIT << "_MEM_RD(" << par << " - 1 downto 1);\n";
                    }

                } else {
                    if (((limArrayIT->second).inputConnectionsType).front() == "OLiM" ||
                        ((limArrayIT->second).inputConnectionsType).front() == "none") {
                        *compFd << "\t\t\t\t\tMem(" << std::stoi(rowAddr.str(), 0, 16) / 4 << ") <= ROW_"
                                << ((limArrayIT->second).inputConnections).front() << "_OUT;\n";
                    } else {
                        *compFd << "\t\t\t\t\tMem(" << std::stoi(rowAddr.str(), 0, 16) / 4 << ") <= ROW_"
                                << ((limArrayIT->second).inputConnections).front() << "_MEM_RD;\n";
                    }

                }


                // clearing the rowAddr stream
                rowAddr.clear();
                rowAddr.str(std::string());
            }
        }
    }


    *compFd << "\t\t\t\tend if;\n"
            << "\t\t\tend if;\n"
            << "\tend process;\n\n";

    // reading process for what concerns the carrying out of the algorithm
    *compFd << "\tgo_rd_proc: process (CLK)\n"
            << "\t\tbegin\n"
            << "\t\t\tif (RST = '1') then\n";

    // if RST is active (high), all the outputs of the LiM rows are set to all zeros
    for (auto mapIT = ((*compArray).limArray).begin(); mapIT != ((*compArray).limArray).end(); ++mapIT) {
        *compFd << "\t\t\t\tROW_" << (mapIT->first) << "_MEM_RD <= (others => '0');\n";
    }

    firstEnter = true;

    /*
      cycling over the FSM structure in order to specify the memory rows to be read. The
      reading of rows can happen only at Ti where i is an even number
    */
    for (FSMIT = ((*compFSM).FSM).begin(); FSMIT != ((*compFSM).FSM).end(); ++FSMIT) {
        firstEnter = true;

        // cycling over the list of operations to be performed during the current FSM time
        for (FSM_ListIT = (FSMIT->second).begin(); FSM_ListIT != (FSMIT->second).end(); ++FSM_ListIT) {

            // if firstEnter is true, an if or elsif statement must be added
            if (firstEnter) {

                // if it is the first element of the FSM, the GO signal must be put inside the if statement
                if (FSMIT->first == 0) {
                    *compFd << "\t\t\telsif (GO = '1') then\n";
                } else {
                    *compFd << "\t\t\telsif (T" << (FSMIT->first) * 2 << " = '1') then\n";
                }

                // setting firstEnter to false in order not to print 2 subsequent if or elsif
                firstEnter = false;
            }

            // writing to rowAddr the row name got from the current iterator
            rowAddr << *FSM_ListIT;
            // printing the read statement for the memory location pointed by rowAddr/4.
            // The signal specified by the address of the address of the current row is assigned with the memory location pointed by rowAddr/4.
            *compFd << "\t\t\t\tROW_" << *FSM_ListIT << "_MEM_RD <= Mem(" << std::stoi(rowAddr.str(), 0, 16) / 4
                    << ");\n";

            // clearing the rowAddr stringstream
            rowAddr.clear();
            rowAddr.str(std::string());
        }
    }

    *compFd << "\t\t\tend if;\n"
            << "\tend process;\n\n";

    // process in charge of activating the proper "enable" signals (Ti) at the proper time
    *compFd << "\tt_proc: process (CLK, RST)\n"
            << "\t\tbegin\n"
            << "\t\t\tif (RST = '1') then\n";

    // In total, ((*compFSM).getFSMSize())*2 - 2 signals, because GO and DONE are excluded
    for (int i = 1; i < ((*compFSM).getFSMSize()) * 2 - 1; ++i) {
        *compFd << "\t\t\t\tT" << i << " <= '0';\n";
        *sigFd << "\tsignal T" << i << ": std_logic;\n";
    }

    *compFd << "\t\t\t\tDONE <= '0';\n"
            << "\t\t\telse\n"
            << "\t\t\t\tif (CLK'event and CLK = '1') then\n";

    // assignment Ti = Ti-1, except for T1 = GO and DONE = Tlast
    for (int i = 1; i < ((*compFSM).getFSMSize()) * 2; ++i) {
        if (i == 1) {
            *compFd << "\t\t\t\t\tT" << i << " <= GO;\n";
        } else if (i == ((*compFSM).getFSMSize()) * 2 - 1) {
            *compFd << "\t\t\t\t\tDONE" << " <= T" << i - 1 << ";\n";
        } else {
            *compFd << "\t\t\t\t\tT" << i << " <= T" << i - 1 << ";\n";
        }
    }

    *compFd << "\t\t\t\tend if;\n"
            << "\t\t\tend if;\n"
            << "\tend process;\n\n";




    // process handling selections signals for 2-to-1 muxes
    *compFd << "\tmux_proc: process (CLK, RST)\n"
            << "\t\tbegin\n"
            << "\t\t\tif (RST = '1') then\n";

    for (auto listIT = (compFSM->selectionSignalsList).begin();
         listIT != (compFSM->selectionSignalsList).end(); ++listIT) {
        *compFd << "\t\t\t\tROW_" << listIT->destRow << "_SEL <= 'X';\n";
    }

    //Cycling over each time in fsm
    for (int i = 0; i < (*compFSM).getFSMSize(); ++i) {

        // if it is the first element of the FSM, the GO signal must be put inside the if statement
        if (i == 0) {
            *compFd << "\t\t\telsif (GO = '1') then\n";
        } else {
            *compFd << "\t\t\telsif (T" << i * 2 << " = '1') then\n";
        }

        //Finding all muxes active in that specific time instant
        for (auto listIT = ((*compFSM).selectionSignalsList).begin();
             listIT != ((*compFSM).selectionSignalsList).end(); ++listIT) {

            if (listIT->activeTimeList.front() == i) {
                *compFd << "\t\t\t\tROW_" << listIT->destRow << "_SEL <= '0';\n";
            } else if (listIT->activeTimeList.back() == i) {
                *compFd << "\t\t\t\tROW_" << listIT->destRow << "_SEL <= '1';\n";
            }

        }
    }

    *compFd << "\t\t\tend if;\n"
            << "\tend process;\n\n";
}

/// It prints the testbench for the .vhd LiM component created
void PrintVhdlFile::printTestbench() {
    // Testbench file
    std::string tbName = "tb.vhd";
    std::error_code ErrorInfoTb;
    tbFile = new raw_fd_ostream(tbName.c_str(), ErrorInfoTb, llvm::sys::fs::F_None);
    if (ErrorInfoTb) {
        errs() << "Error opening file: " << tbName << "\n";
        llvm_unreachable("Error in PrintVhdlFile: unable to create the .txt file.");
    }

    // getting the number of input data that the algorithm needs, but also the number of its outputs
    std::string numInputs = getNumberInputs();
    std::string numOutputs = getNumberOutputs();

    if (debugMode) {
        errs() << "NINP " << numInputs << "\n";
        errs() << "NOUTP " << numOutputs << "\n";
    }

    // entity, component and test signals declaration
    std::string constInit = "library IEEE;\n"
                            "use IEEE.std_logic_1164.all;\n"
                            "use IEEE.numeric_std.all;\n"
                            "\n"
                            "entity EntityName_TB is\n"
                            "end entity;\n"
                            "\n"
                            "architecture test of EntityName_TB is\n"
                            "\t\n"
                            "\tcomponent EntityName\n"
                            "\t\tgeneric(\n"
                            "\t\t\t\tword_size: integer;\n"
                            "\t\t\t\tentries: integer);\t\n"
                            "\t\tport(   \n"
                            "\t\t\t\tclk: in std_logic;\n"
                            "\t\t\t\trst: in std_logic;\n"
                            "\t\t\t\ten: in std_logic;\n"
                            "\t\t\t\tgo: in std_logic;\n"
                            "\t\t\t\tdone: out std_logic;\n"
                            "\t\t\t\treadnotwrite: in std_logic; \n"
                            "\t\t\t\taddress: in std_logic_vector(word_size - 1 downto 0);\n"
                            "\t\t\t\tdata_in: in std_logic_vector(word_size - 1 downto 0);  \n"
                            "\t\t\t\tdata_out: out std_logic_vector(word_size - 1 downto 0));\n"
                            "\tend component;\n"
                            "\n"
                            "\tsignal clk_i : std_logic := '1';\n"
                            "\tsignal rst_i : std_logic;\n"
                            "\tsignal en_i : std_logic := '0';\n"
                            "\tsignal go_i : std_logic := '0';\n"
                            "\tsignal done_i : std_logic := '0';\n"
                            "\tsignal readnotwrite_i : std_logic := '0';\n";

    *tbFile << constInit
            << "\tsignal address_i : std_logic_vector(" << par << " - 1 downto 0);\n"
            << "\tsignal data_in_i : std_logic_vector(" << par << " - 1 downto 0);\n"
            << "\tsignal data_out_i : std_logic_vector(" << par << " - 1 downto 0);\n\n";

    *tbFile << "\ttype resultArray is array (0 to " << numOutputs << " - 1) of integer;\n";
    *tbFile << "\tconstant result_address_vector : resultArray := (";

    std::stringstream ss;
    int address;
    std::string addressList;

    for (auto listIT = resultRowList.begin(); listIT != resultRowList.end(); ++listIT) {

        ss << std::hex << *listIT;
        ss >> address;
        ss.clear();
        addressList += std::to_string(static_cast<int>(address) / 4);
        addressList += ", ";

    }

    addressList.pop_back();
    addressList.pop_back();
    addressList += ");\n";

    *tbFile << addressList;
    *tbFile << "begin\n\n";

    // port mapping of the LiM component
    *tbFile << "\tcomp: EntityName generic map (word_size => " << par << ", entries =>" << entries << ")\n";

    std::string compInst = "\t\t\t\t\t\t\t\t\tport map(clk => clk_i, rst => rst_i, en => en_i, go => go_i, done => done_i, readnotwrite => readnotwrite_i, \n"
                           "\t\t\t\t\t\t\t\t\taddress => address_i, data_in => data_in_i, data_out => data_out_i);\n\n";

    // clock and reset process
    std::string clkRst = "\tclk_i <= not(clk_i) after 0.5 ns;\n"
                         "\t\n"
                         "\trst_proc : process \n"
                         "\t\tbegin\t\t\t\n"
                         "\t\t\trst_i <= '1';\n"
                         "\t\t\twait for " + numOutputs + " ns;\n"
                                                          "\t\t\trst_i <= '0';\n"
                                                          "\t\t\twait;\n"
                                                          "\tend process;\n\n";

    // process generating the address to give in input to the LiM in each clock cycle in order to test the component.
    // If done = '1', it means that results are ready to be read, so the address is set in order to point to the first of the results.
    // If the address reaches its maximum value, it is reset to zero
    std::string cntProc = "\tcnt_proc: process(rst_i, clk_i) \n"
                          "\t\tvariable cnt : integer := 0;\n"
                          "\t\tvariable writeOutputs : integer := 0;\n"
                          "\t\tbegin\n"
                          "\t\t\tif(rst_i = '1') then\n"
                          "\t\t\t\tcnt := 0;\n"
                          "\t\t\telsif (clk_i'event and clk_i = '1') then\n"
                          "\t\t\t\tif (cnt = " + std::to_string(entries - 1) + " and done_i = '0') then\n"
                                                                               "\t\t\t\t\tcnt := 0;\n"
                                                                               "\t\t\t\telsif done_i = '1' then\n"
                                                                               "\t\t\t\t\tcnt := 0;\n"
                                                                               "\t\t\t\t\twriteOutputs := 1;\n"
                                                                               "\t\t\t\telse \n"
                                                                               "\t\t\t\t\tif(writeOutputs /= 1) then\n"
                                                                               "\t\t\t\t\t\tcnt := cnt + 1;\n"
                                                                               "\t\t\t\t\telse\n"
                                                                               "\t\t\t\t\t\tcnt := result_address_vector(cnt);\n"
                                                                               "\t\t\t\t\tend if;\n"
                                                                               "\t\t\t\tend if;\n"
                                                                               "\t\t\tend if;\n"
                                                                               "\t\t\t\n"
                                                                               "\t\t\taddress_i <= std_logic_vector(to_unsigned(cnt, " +
                          std::to_string(par) + "));\n"
                                                "\tend process;\n\n";

    // process managing the enable signal. During the first time after the simulation starts,
    // there is an overhead due to the reset signal. The the writing and reading phases of two consecutive tests are directly connected,
    // hence en_i = '1' during both phases. en_i = '0' during the algorithm calculations, so it needs to wait for done_i to go to '1'
    std::string enProc = "\ten_proc: process\t\n"
                         "\t\tvariable first : boolean := true;\n"
                         "\t\tbegin\n"
                         "\t\t\tif first then\n"
                         "\t\t\t\twait for " + numOutputs + " ns;\n"
                                                            "\t\t\t\tfirst := false;\n"
                                                            "\t\t\tend if;\n"
                                                            "\t\t\ten_i <= '1';\n"
                                                            "\t\t\treadnotwrite_i <= '0';\n"
                                                            "\t\t\twait for " + numInputs + " ns;\n"
                                                                                            "\t\t\ten_i <= '0';\n"
                                                                                            "\t\t\twait until done_i'event and done_i = '0';\n"
                                                                                            "\t\t\ten_i <= '1';\n"
                                                                                            "\t\t\treadnotwrite_i <= '1';\n"
                                                                                            "\t\t\twait for " +
                         numOutputs + " ns;\n"
                                      "\tend process;\n\n";

    // process properly generating the go signal. which is set to '1' when en has a falling edge (after writing all inputs of algorithm)
    std::string goProc = "\tgo_proc: process\n"
                         "\t\tbegin\n"
                         "\t\t\twait until en_i'event and en_i = '0';\n"
                         "\t\t\tgo_i <= '1';\n"
                         "\t\t\twait for 1 ns;\n"
                         "\t\t\tgo_i <= '0';\t\n"
                         "\tend process;\n\n";

    // process managing the writing of algorithm inputs into the LiM
    std::string wrtProc = "\twrt_proc: process\n"
                          "\t\tvariable first : boolean := true;\n"
                          "\t\tbegin\n"
                          "\t\t\tif first then\n"
                          "\t\t\t\twait until en_i'event and en_i = '1' and readnotwrite_i = '0';\n"
                          "\t\t\t\tfirst := false;\n"
                          "\t\t\telse\n"
                          "\t\t\t\twait until en_i = '1' and readnotwrite_i = '0';\n"
                          "\t\t\tend if;\n";

    for (int i = 0; i < std::stoi(numInputs); ++i) {
        wrtProc += "\t\t\tdata_in_i <= std_logic_vector(to_unsigned(";
        wrtProc += std::to_string(i);
        wrtProc += ", ";
        wrtProc += std::to_string(par);
        wrtProc += "));\n\t\t\twait for 1 ns;\t\t\n";
    }

    wrtProc += "\tend process;\n\n";

    *tbFile << compInst << clkRst << cntProc << wrtProc << enProc << goProc;

    *tbFile << "\nend test;";


    (*tbFile).close();

}